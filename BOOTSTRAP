#!/usr/bin/perl
# ---   *   ---   *   ---
# BOOTSTRAP
# A BUILD TOOL MUST BUILD ITSELF
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package BOOTSTRAP;
  use v5.42.0;
  use strict;
  use warnings;

  use English qw($ARG $ERRNO);
  use Module::Load qw(load);
  use File::Path qw(mkpath rmtree);


# ---   *   ---   *   ---
# info

  our $VERSION = 'v2.00.1';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# check that ARPATH exists
#
# then move into it

BEGIN {
  exists $ENV{ARPATH}
  or die "ARPATH missing from ENV; aborted";

  chdir "$ENV{ARPATH}/avtomat/"
  or die "$ERRNO";

};


# ---   *   ---   *   ---
# ROM

my $ROM={
  ROOTDIR  => "$ENV{ARPATH}",
  AVTODIR  => "$ENV{ARPATH}/avtomat/",
  TRASHDIR => "$ENV{ARPATH}/.trash/avtomat/",
  LIBDIR   => "$ENV{ARPATH}/lib/",
  BINDIR   => "$ENV{ARPATH}/bin/",

  FMAT => {
    BOOT    => "\e[37;1m<\e[36;1mBOOT\e[37;1m>\e[0m",
    AR      => "\e[37;1m<\e[34;22mAR\e[37;1m>\e[0m",
    FNAME   => "\e[32;1m",
    STEP    => "\e[37;1m::\e[0m",
    SUBSTEP => "  ",

  },


  # these files are needed for building
  # everything else!
  #
  # as such, it's best their own dependencies
  # remain either untouched or as minimal
  # as possible...

  MAMDEPS=>[qw(
    /sys/Style.pm
    /sys/Chk.pm
    /sys/Arstd/Repl.pm

  )],


  # MAM does not depend on these files,
  # so we can mess with their deps alright ;>
  AVTODEPS=>[qw(
    /sys/Frame.pm
    /sys/St.pm

    /AR.pm
    /sys/Arstd/Array.pm
    /sys/Arstd/String.pm

  )],

#    /sys/Arstd/Bin.pm
#    /sys/Arstd/Path.pm
#    /sys/Arstd/Re.pm
#    /sys/Arstd/IO.pm
#    /sys/Arstd/Bytes.pm
#    /sys/Arstd/Int.pm
#    /sys/Arstd/Hash.pm
#    /sys/Arstd/PM.pm
#    /sys/Arstd/WLog.pm
#    /sys/Arstd/Fmat.pm
#
#    /sys/Cli.pm
#    /sys/Warnme.pm
#
#    /sys/Queue.pm
#    /sys/Cask.pm
#    /sys/Tree.pm
#    /sys/Tree/File.pm
#    /sys/Tree/Dep.pm
#
#    /sys/Type/MAKE.pm
#    /sys/Type.pm
#
#    /sys/Type/C.pm
#    /sys/Type/Cpp.pm
#
#    /sys/Shb7.pm
#    /sys/Shb7/Path.pm
#    /sys/Shb7/Find.pm
#    /sys/Shb7/Bfile.pm
#    /sys/Shb7/Bk.pm
#    /sys/Shb7/Bk/flat.pm
#    /sys/Shb7/Bk/gcc.pm
#    /sys/Shb7/Bk/mam.pm
#    /sys/Shb7/Bk/fake.pm
#    /sys/Shb7/Build.pm
#
#    /sys/Vault.pm
#    /sys/Cli.pm
#
#    /sys/Ftype.pm
#    /sys/Ftype/Text.pm
#    /sys/Ftype/Text/fasm.pm
#    /sys/Ftype/Text/C.pm
#    /sys/Ftype/Text/peso.pm
#    /sys/Ftype/Text/SinGL.pm
#    /sys/Ftype/Text/Perl.pm
#    /sys/Ftype/Text/Python.pm
#    /sys/Ftype/Text/Js.pm
#    /sys/Ftype/Text/Mny.pm
#
#    /Emit.pm
#    /Emit/Std.pm
#    /Emit/C.pm
#    /Emit/Perl.pm
#
#    /Avt/Sieve.pm
#    /Avt/Xcav/C.pm
#    /Avt/Xcav.pm
#    /Avt/Makescript.pm
#    /Avt.pm
#
#  )],

};


# ---   *   ---   *   ---
# nuke

sub build_clean {
  rmtree("../.trash/",{safe=>1});
  rmtree("../.cache/",{safe=>1});
  rmtree("../lib/",{safe=>1});

  return;

};


# ---   *   ---   *   ---
# make

sub build_mkdirs {
  map {mkpath($ARG) if ! -e $ARG} (
    $ROM->{TRASHDIR},
    $ROM->{LIBDIR},
    $ROM->{BINDIR},

  );

  return;

};


# ---   *   ---   *   ---
# procs MAM so that it can proc other files ;>

sub procmam($rap) {
  my ($dst,$src)=(undef,undef);

  # swap destination?
  my ($tmpdir,$dstdir,$srcdir)=($rap)
    ? ($ROM->{AVTODIR},$ROM->{TRASHDIR},
       $ROM->{LIBDIR})

    : ($ROM->{TRASHDIR},$ROM->{LIBDIR},
       $ROM->{LIBDIR})
    ;

  my $dstname="$dstdir/MAM.pm";


  # orc the source
  open  $src,'<','./MAM.pm'  or die "$ERRNO";
  read  $src,my $body,-s $src;
  close $src or die "$ERRNO";

  # ^swap library locations
  my $root = $ROM->{ROOTDIR};
  my $env  = quotemeta '$ENV{ARPATH}';

  $srcdir =~ s[$root][$env];
  $dstdir =~ s[$root][\$ENV{ARPATH}];
  $tmpdir =~ s[$root][\$ENV{ARPATH}];
  $body   =~ s[$srcdir][$tmpdir]sxmg;

  # ^owc to destination
  open  $dst,'+>',$dstname or die "$ERRNO";
  print {$dst} "$body";
  close $dst or die "$ERRNO";


  return;

};


# ---   *   ---   *   ---
# "older than"
# return a is older than b

sub ot($a,$b) {
  return (
      (defined $a && -f $a)
  &&  (defined $b && -f $b)

  &&! ( (-M $a) < (-M $b) )

  );

};

# ---   *   ---   *   ---
# "missing or older"
# file not found or file needs update

sub moo($a,$b) {
  return (defined $a &&! -f $a) || ot($a,$b);

};


# ---   *   ---   *   ---
# do we have to?

sub need_update($dstdir,$srcdir,$fname) {
  my $src="$srcdir$fname";
  my $dst="$dstdir$fname";

  my $need=(-e $dst)
    ? moo($dst,$src)
    : 1
    ;


  return ($need)
    ? [$dst,$src,$fname]
    : ()
    ;

};


# ---   *   ---   *   ---
# ensure basedir of file exists

sub req_basedir($dst) {
  my @ar      = split '/',$dst;
  my $basedir = join '/',@ar[0..$#ar-1];

  mkpath($basedir) if ! -e $basedir;

  return pop @ar;

};


# ---   *   ---   *   ---
# summons MAM

sub runmam($dstdir,$srcdir,$src,$rap) {
  my @args=('-Mavtomat',"-f$src","-r$rap");

  load lib=>$dstdir;
  load 'MAM';

  # make filter
  my $mam=MAM->new(@args);
  return $mam->run();

};


# ---   *   ---   *   ---
# in: file list,src path,dst path
# check dates, update older files

sub update($dstdir,$srcdir,$list,$rap) {
  my $tag=$ROM->{FMAT}->{SUBSTEP};

  return int map {
    my ($dst,$src,$fname)=@$ARG;

    # run MAM
    my $out=runmam($dstdir,$srcdir,$src,$rap);

    # owc and prich
    req_basedir $dst;

    open  my $fh,'+>',$dst or die "$!";
    print {$fh} $out;
    close $fh;

    say {*STDERR} "$tag$fname";
    1;


  } map {
    need_update $dstdir,$srcdir,$ARG

  } @$list;

};


# ---   *   ---   *   ---
# builds ~~

sub make($name,$list) {
  my @tag=(
    ($name eq 'MAM')
      ? $ROM->{FMAT}->{BOOT}
      : $ROM->{FMAT}->{AR}
      ,

    $ROM->{FMAT}->{FNAME} . "${name}\e[0m",
    $ROM->{FMAT}->{STEP},

  );


  # initial MAM run
  # needed to apply source filters
  say {*STDERR} "$tag[2]updating $tag[1]";

  procmam 1 if $name eq 'MAM';
  my $need=update(
    $ROM->{TRASHDIR},
    $ROM->{AVTODIR},
    $list,
    1

  );

  procmam 0 if $name eq 'MAM';


  # ^if nothing was updated, then a
  # ^second run never happens
  if($need) {
    say {*STDERR} (
      "\n$tag[2]copying from "
    . "\e[36;1m\"/.trash/\"\e[0m"

    );

    update(
      $ROM->{LIBDIR},
      $ROM->{TRASHDIR},
      $list,
      0

    );

  };


  return;

};


# ---   *   ---   *   ---
# entry point

sub run {
  my $tag=$ROM->{FMAT}->{BOOT};

  # handle args, run sanity checks...
  say {*STDERR} "${tag}running bootstrap";

  build_clean if int grep {$ARG eq 'clean'} @ARGV;
  build_mkdirs;

  # run build
  make MAM=>$ROM->{MAMDEPS};

  $tag=$ROM->{FMAT}->{STEP};
  say {*STDERR} "${tag}done\n";

  $ENV{ARLIB}="$ROM->{TRASHDIR}/avtomat/";
  $tag=$ROM->{FMAT}->{AR};
  say {*STDERR} "${tag}starting update";
  make avtomat=>$ROM->{AVTODEPS};


  # rebuild nanorc files ;>
  $tag=$ROM->{FMAT}->{STEP};
  say {*STDERR} "${tag}rebuilding syntax files";
#  say {*STDERR} `./bin/sygen`;
  say {*STDERR} "${tag}done\n";


  return;

};

run;


# ---   *   ---   *   ---
1; # ret

