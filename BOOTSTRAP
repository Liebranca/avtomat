#!/usr/bin/perl
# ---   *   ---   *   ---
# BOOTSTRAP
# A BUILD TOOL MUST BUILD ITSELF
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package BOOTSTRAP;
  use v5.42.0;
  use strict;
  use warnings;

  use English qw($ARG $ERRNO);
  use Module::Load qw(load);
  use File::Path qw(mkpath rmtree);


# ---   *   ---   *   ---
# info

  our $VERSION = 'v2.00.1';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# check that ARPATH exists
#
# then move into it

BEGIN {
  exists $ENV{ARPATH}
  or die "ARPATH missing from ENV; aborted";

  chdir "$ENV{ARPATH}/avtomat/"
  or die "$ERRNO";
};


# ---   *   ---   *   ---
# ROM

my $ROM={
  ROOTDIR  => "$ENV{ARPATH}",
  AVTODIR  => "$ENV{ARPATH}/avtomat/",
  TRASHDIR => "$ENV{ARPATH}/.trash/avtomat/",
  LIBDIR   => "$ENV{ARPATH}/lib/",
  BINDIR   => "$ENV{ARPATH}/bin/",

  FMAT => {
    BOOT    => "\e[37;1m<\e[36;1mBOOT\e[37;1m>\e[0m",
    AR      => "\e[37;1m<\e[34;22mAR\e[37;1m>\e[0m",
    FNAME   => "\e[32;1m",
    STEP    => "\e[37;1m::\e[0m",
    SUBSTEP => "  ",
  },

  # these files are needed for building
  # everything else!
  #
  # as such, it's best their own dependencies
  # remain either untouched or as minimal
  # as possible...
  MAMDEPS=>[qw(
    /sys/Style.pm
    /sys/Chk.pm
    /sys/Arstd/String.pm
    /sys/Arstd/Path.pm
    /sys/Arstd/ansi.pm
    /sys/Arstd/throw.pm
    /sys/Arstd/Bin.pm
    /sys/Arstd/Array.pm
    /sys/Arstd/Hash.pm
    /sys/Arstd/IO.pm
    /sys/Arstd/Re.pm
    /sys/Arstd/PM.pm
    /sys/Arstd/seq.pm
    /sys/Arstd/strtok.pm
    /sys/Arstd/peso.pm
    /sys/Arstd/repl.pm
    /sys/Shb7/Path.pm
    /sys/Shb7/Find.pm
    /sys/Chk/Syntax.pm
    /sys/Chk/Deps.pm

    /AR.pm
    /sys/Arstd/rd.pm
    /sys/Arstd/pproc.pm
    /sys/Frame.pm
    /sys/St.pm
  )],

  # MAM does not depend on these files,
  # so we can mess with their deps alright ;>
  AVTODEPS=>[qw(
    /sys/Arstd/Token.pm
    /sys/Arstd/Bytes.pm
    /sys/Arstd/Int.pm
    /sys/Arstd/stoi.pm
    /sys/Arstd/Fmat.pm
    /sys/Arstd/fatdump.pm
    /sys/Arstd/xd.pm

    /sys/Ftype.pm
    /sys/Ftype/Text.pm
    /sys/Ftype/Text/fasm.pm
    /sys/Ftype/Text/C.pm
    /sys/Ftype/Text/peso.pm
    /sys/Ftype/Text/SinGL.pm
    /sys/Ftype/Text/Perl.pm
    /sys/Ftype/Text/Python.pm
    /sys/Ftype/Text/Js.pm
    /sys/Ftype/Text/Mny.pm
    /sys/Ftype/Text/cfg.pm

    /sys/Tree.pm
    /sys/Tree/File.pm
    /sys/Tree/Dep.pm
    /sys/Tree/C.pm

    /sys/Type/MAKE.pm
    /sys/Type.pm

    /sys/Log.pm
    /sys/Warnme.pm
    /sys/Cli.pm

    /sys/Queue.pm
    /sys/Cask.pm

    /sys/Type/MAKE.pm
    /sys/Type.pm
    /sys/Type/C.pm
    /sys/Type/Cpp.pm

    CMAM/static.pm
    CMAM/macro.pm
    CMAM/parse.pm
    CMAM/emit.pm
    CMAM/sandbox.pm
    CMAM.pm

    /sys/Shb7/Bfile.pm
    /sys/Shb7/Bk.pm
    /sys/Shb7/Bk/flat.pm
    /sys/Shb7/Bk/cmam.pm
    /sys/Shb7/Bk/mam.pm
    /sys/Shb7/Bk/fake.pm
    /sys/Shb7/Build.pm
    /sys/Shb7/Link.pm
    /sys/Shb7.pm

    /sys/Vault.pm

    /Emit.pm
    /Emit/Std.pm
    /Emit/C.pm
    /Emit/Perl.pm

    /Avt/Sieve.pm
    /Avt/XS/Type.pm
    /Avt/XS.pm
    /Avt/Makescript.pm
    /Avt.pm
  )],
};


# ---   *   ---   *   ---
# nuke

sub build_clean {
  rmtree("../.trash/",{safe=>1});
  rmtree("../.cache/",{safe=>1});
  rmtree("../lib/",{safe=>1});

  return;
};


# ---   *   ---   *   ---
# make

sub build_mkdirs {
  map {mkpath($ARG) if ! -e $ARG} (
    $ROM->{TRASHDIR},
    $ROM->{LIBDIR},
    $ROM->{BINDIR},
  );

  return;
};


# ---   *   ---   *   ---
# procs MAM so that it can proc other files ;>
#
# [0]: bool ; MAM build step (rap)
#
# [*]: this simply makes a copy of MAM
#      source with library paths swapped
#
#      we do this so that it can import it's
#      own dependencies _while_ it is building
#      them (as they'd be missing from the
#      actual library path)

sub procmam {
  my ($dst,$src)=(undef,undef);

  # swap destination?
  my ($tmpdir,$dstdir,$srcdir)=($_[0])
    ? ($ROM->{AVTODIR},$ROM->{TRASHDIR},
       $ROM->{LIBDIR})

    : ($ROM->{TRASHDIR},$ROM->{LIBDIR},
       $ROM->{LIBDIR})
    ;

  my $dstname="$dstdir/MAM.pm";


  # orc the source
  open  $src,'<','./MAM.pm'  or die "$ERRNO";
  read  $src,my $body,-s $src;
  close $src or die "$ERRNO";

  # ^swap library locations
  my $root = $ROM->{ROOTDIR};
  my $env  = quotemeta '$ENV{ARPATH}';

  $srcdir =~ s[$root][$env];
  $dstdir =~ s[$root][\$ENV{ARPATH}];
  $tmpdir =~ s[$root][\$ENV{ARPATH}];
  $body   =~ s[$srcdir][$tmpdir]sxmg;

  # ^owc to destination
  open  $dst,'+>',$dstname or die "$ERRNO";
  print {$dst} "$body";
  close $dst or die "$ERRNO";

  return;
};


# ---   *   ---   *   ---
# "older than"
# return a is older than b
#
# [0]: byte ptr ; build filepath
# [1]: byte ptr ; source filepath
#
# [<]: bool ; build older than source

sub ot {
  return (
      (defined $_[0] && -f $_[0])
  &&  (defined $_[1] && -f $_[1])

  &&! ( (-M $_[0]) < (-M $_[1]) )
  );
};


# ---   *   ---   *   ---
# "missing or older"
# file not found or file needs update
#
# [0]: byte ptr ; build filepath
# [1]: byte ptr ; source filepath
#
# [<]: bool ; build missing or older than source

sub moo {
  return (
     (defined $_[0] &&! -f $_[0])
  || ot($_[0],$_[1])
  );
};


# ---   *   ---   *   ---
# do we have to?
#
# [0]: byte ptr ; build directory
# [1]: byte ptr ; source directory
# [2]: byte ptr ; filename (no dir)
#
# [<]: mem ptr ; arrayref with all three args
#                if build is needed; else null

sub need_update {
  my $src  = "$_[1]$_[2]";
  my $dst  = "$_[0]$_[2]";
  my $need = (-e $dst) ? moo($dst,$src) : 1 ;

  return ($need) ? [$dst,$src,$_[2]] : () ;
};


# ---   *   ---   *   ---
# ensure basedir of file exists
#
# [0]: byte ptr ; filename
# [<]: byte ptr ; directory (new string)

sub req_basedir {
  my @ar      = split qr{/},$_[0];
  my $basedir = join '/',@ar[0..$#ar-1];

  mkpath($basedir) if ! -e $basedir;

  return pop @ar;
};


# ---   *   ---   *   ---
# makes MAM ice
#
# [0]: byte ptr ; destination directory
# [1]: bool     ; MAM build step (rap)
#
# [<]: mem ptr ; new MAM instance
#
#
# [*]: it would possible to use a single
#      MAM instance for the entire build;
#
#      but since MAM source itself is updated
#      by BOOTSTRAP, we need to reimport it.
#
#      because of that, we spawn four instances
#      in total (at most) during these steps:
#
#      1. building MAM dependencies themselves.
#      2. re-processing those built files.
#
#      3. building avtomat dependencies with the
#         (now-updated) MAM.
#
#      4. re-processing built files for avtomat.
#
#
# [*]: which one of those four is executed depends
#      on whether the previous step was needed;
#
#      if a dependency was updated, then everything
#      depending on it will, logically, be updated
#      as well.

sub mkmam {
  # get package from build or final dir
  load lib=>$_[0];
  load 'MAM';

  # ^set root and make ice
  $ENV{MAMROOT}=$ROM->{ROOTDIR};
  my $mam=MAM->new();

  # ^configure and give
  $mam->set_module('avtomat');
  $mam->set_rap($_[1]);

  return $mam;
};


# ---   *   ---   *   ---
# update files in list if need
#
# [0]: mem ptr ; filename arrayref
# [1]: bool    ; MAM build step (rap)

sub update {
  # paths used depend on build step
  my ($dstdir,$srcdir)=($_[1])
    ? ($ROM->{TRASHDIR},$ROM->{AVTODIR})
    : ($ROM->{LIBDIR},$ROM->{TRASHDIR})
    ;

  # get whether any of these files
  # need to be updated
  my @need=map {
    need_update $dstdir,$srcdir,$ARG

  } @{$_[0]};

  # ^skip if none
  return 0 if ! @need;


  # ^else build what's needed
  my $tag=$ROM->{FMAT}->{SUBSTEP};
  my $mam=mkmam($dstdir,$_[1]);

  return int map {
    my ($dst,$src,$fname)=@$ARG;

    # prich out what we're doing
    say {*STDERR} "$tag$fname";

    # process file with MAM
    my $out=$mam->run($dst,$src);

    # ^owc
    req_basedir $dst;

    open  my $fh,'+>',$dst or die "$!";
    print {$fh} $out;
    close $fh;

    1;

  } @need;
};


# ---   *   ---   *   ---
# builds MAM and avtomat
#
# [0]: byte ptr ; name of component
# [1]: mem ptr  ; filename arrayref

sub make {
  my @tag=(
    ($_[0] eq 'MAM')
      ? $ROM->{FMAT}->{BOOT}
      : $ROM->{FMAT}->{AR}
      ,

    $ROM->{FMAT}->{FNAME} . "$_[0]\e[0m",
    $ROM->{FMAT}->{STEP},
  );


  # initial MAM run
  # needed to apply source filters
  say {*STDERR} "$tag[2]updating $tag[1]";

  procmam 1 if $_[0] eq 'MAM';
  my $need=update($_[1],1);


  # we make sure to _always_ update MAM source,
  # as it's a single file and everything else
  # depends on it ;>

  procmam 0 if $_[0] eq 'MAM';
  return if ! $need;


  # everything else is only updated
  # when there's an actual change
  say {*STDERR} (
    "\n$tag[2]copying from "
  . "\e[36;1m\"/.trash/\"\e[0m"
  );

  update($_[1],0);
  return;
};


# ---   *   ---   *   ---
# entry point

sub run {
  my $tag=$ROM->{FMAT}->{BOOT};

  # handle args, run sanity checks...
  say {*STDERR} "${tag}running bootstrap";

  build_clean if int grep {$ARG eq 'clean'} @ARGV;
  build_mkdirs;

  # run build
  make MAM=>$ROM->{MAMDEPS};

  $tag=$ROM->{FMAT}->{STEP};
  say {*STDERR} "${tag}done\n";

  $ENV{ARLIB}="$ROM->{TRASHDIR}/avtomat/";
  $tag=$ROM->{FMAT}->{AR};
  say {*STDERR} "${tag}starting update";
  make avtomat=>$ROM->{AVTODEPS};


  # importing sygen rebuilds nanorc files ;>
  $tag=$ROM->{FMAT}->{STEP};
  load lib=>"$ENV{ARPATH}/avtomat/bin/";
  load sygen;
  say {*STDERR} "${tag}done\n";
  return;
};

run();


# ---   *   ---   *   ---
1; # ret

