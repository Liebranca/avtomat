#!/usr/bin/perl

# ---   *   ---   *   ---
# AVTOMAT
# build helper and initializer
# generated files manager
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb
# ---   *   ---   *   ---

# deps
package avt;
  use strict;
  use warnings;

# ---   *   ---   *   ---
# info

  use constant {
  
    VERSION        => 2.0,

    CONFIG_DEFAULT => 'x . . 0',

  };

# ---   *   ---   *   ---
# global storage

  my %CACHE=(
    -ROOT => '.',

  );

# ---   *   ---   *   ---
# default prints

# args=author,comment prefix
# generates a notice on top of generated files
sub make_note {

  my $author=shift;
  my $ch=shift;

  my $t=`date +%Y`;
  my $note=<<"EOF"
$ch ---   *   ---   *   ---
$ch LIBRE BOILERPASTE
$ch GENERATED BY AR/AVTOMAT
$ch
$ch LICENSED UNDER GNU GPL3
$ch BE A BRO AND INHERIT
$ch
$ch COPYLEFT $author $t
$ch ---   *   ---   *   ---
EOF

;return $note;

};

# args=name,version,description,author
# generates program info
sub make_version {
  my $version=
    '* '.shift.' v'.shift."\n".
    shift."\n".
    'Copyleft '.shift.'; Licensed under GNU GPL3'."\n"
    
  ;return $version;

};

# ---   *   ---   *   ---
# path utils

# args=path
# recursively list dirs and files in path
sub walk {

  my %dirs=();my $path=shift;

  # dissect recursive ls
  { my @ls=split "\n\n",`ls -FBR1 $path`;
    while(@ls) {
      my @sub=split ":\n",shift @ls;

      # exclude hidden folders and documentation
      if( ($sub[0]=~ m/\./)
      ||  ($sub[0] eq 'docs')      
      ) {next;};

      # shorten dirnames
      $sub[0]=~ s/${ path }//;
      if(!$sub[0]) {$sub[0]='<main>';};

      # remove ws      
      $sub[1]=~ s/^\s+|\s+$//;

# ---   *   ---   *   ---

      # filter out folders and headers
      my @tmp=split "\n",$sub[1];
      my @files=();
      
      while(@tmp) {
        my $entry=shift @tmp;
        if(($entry=~ m/\/|.*\.h|GNUmakefile|Makefile|makefile/)) {
          next;

        };push @files,$entry;

      };

      # dirs{folder}=ref(list of files)
      $dirs{ $sub[0] }=\@files;

    };    

  };return (\%dirs);

};

# ---   *   ---   *   ---

# ensures trsh and bin exist, outs file/dir list
sub scan {

  my $module_list='';
  `echo -n '' > $CACHE{-ROOT}/.avto-modules`;

  # iter provided names
  while(@_) {
    my $mod=shift;
    
    my $trsh="$CACHE{-ROOT}/trashcan/$mod";
    my $modpath="$CACHE{-ROOT}/$mod";

    # ensure there is a trashcan
    if(!(-e $trsh)) {
      system 'mkdir',('-p',"$trsh");

    };

# ---   *   ---   *   ---

    # walk module path and capture sub count
    my %h=%{ walk($modpath) };my $len=keys %h;
    `echo "$mod $len" >> $CACHE{-ROOT}/.avto-modules`;

    # paths/dir checks
    for my $sub (keys %h) {

      # ensure directores exist
      my $tsub=$sub;$tsub=~ s/${ modpath }/${ trsh }/;      
      if(!(-e $trsh)) {      
        mkdir $tsub;

      };

      # capture file list
      my @files=@{ $h{$sub} };
      
      `echo "$sub @files" >> $CACHE{-ROOT}/.avto-modules`;
      
    };`touch $trsh/mklog`;

  };

};

# ---   *   ---   *   ---

# parse modules into hash
sub read_modules {
  
  my %h;{
    my @m=split "\n",`cat $CACHE{-ROOT}/.avto-modules`;

    # get parent name
    while(@m) {
      my ($key,$len)=split ' ',shift @m;
      my @paths;

      # store submodules as references
      while($len--) {
        my @tmp=shift @m;
        push @paths,\@tmp;

      };

      # hash{parent}=( ($path,@files) );
      $h{$key}=\@paths;

    };
  };return \%h;
  
};

# ---   *   ---   *   ---

# manages build config file
sub config {

  my %config;
  while(@_) {
    my $mod=shift @_;    
    my $settings=shift @_;

    $config{$mod}=$settings;

  };

  # rewrite file
  open FH,'>',"$CACHE{-ROOT}/.avto-config" or die $!;
  for my $mod (keys %config) {
    print FH "$mod $config{$mod}\n"

  };close FH;

};

# ---   *   ---   *   ---

# emits a makefile
sub make {

  # add these directories to search path
  # ... but only if they exist, obviously
  
  my $base_lib=(-e $CACHE{-ROOT}.'/lib')
    ? $CACHE{-ROOT}.'/lib'
    : ''
    ;

  my $base_include=(-e $CACHE{-ROOT}.'/include')
    ? $CACHE{-ROOT}.'/include'
    : ''
    ;

# ---   *   ---   *   ---

  # fetch dir/file list
  my %modules=%{ read_modules($CACHE{-ROOT}) };

  # fetch config
  my @config=split "\n",`cat $CACHE{-ROOT}/.avto-config`;

  # now iter 
  while(@config) {

    my (    
      $name,
      $mode,
      $lib,
      $include,
      $define
      
    )=split ' ',shift @config;

    my @paths=@{ $modules{$name} };
    print "$mode:$name:$lib:$include:$define\n\n";
    while(@paths) {
      my @path=@{ shift @paths };
      print @path;
      print "\n\n";

    };

  };

};

# ---   *   ---   *   ---
# entry point

package main;
  use Cwd qw(abs_path);

  if(!@ARGV || $ARGV[0] eq 'help') {
    # put helper here

  };$CACHE{-ROOT}=abs_path shift;
  chdir $CACHE{-ROOT};

# ---   *   ---   *   ---
# run

  my $task=shift;my %tasks=(
    'scan'    => \&avt::scan,
    'config'  => \&avt::config,
    'make'    => \&avt::make,

  );
  
  if(grep $task,keys %tasks) {
    $tasks{$task}->(@ARGV);

  };

# ---   *   ---   *   ---

my $log=
  'AR/AVTOMAT: last run by '.
  `echo -n \$USER`.'@'.`echo -n \$HOSTNAME`.
  ' on '.`date`."\n\n";

`echo "$log" > $CACHE{-ROOT}/.avto`;



# ---   *   ---   *   ---
1; # ret
