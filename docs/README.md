# AVTOMAT

This is a build helper designed to relieve me of the burden of maintaining makefiles; GNU make was my tool of preference for automating builds, but since writing it's input by hand could age me a decade in a single afternoon, I began looking for an alternative...

... but the alternatives were a tad on the silly side, so I bit the bullet and rolled out my own instead.

The result: avtomat. It is KISS: you point it at a folder and it spits out a list of files and directories. You then pass it some info on what you want to build, and it'll make a config file out of that. Finally, you tell avtomat to generate build scripts, and it does just that.

Generated scripts are in Perl, because I love Perl. Also it's most likely installed on your distro by default, so no pulling extrabloat: it's a win-win.

# FEATURES

- **Shadow libs**: executables emit static libraries containing their sources after compilation; thus, any code you want to reuse can simply be included in a later project, without having to explicitly shuffle files around.

- **Dependency solver**: if a list of dependencies is passed to the build configuration of a library, then passing the name of that library to any subsequent build config will expand into the previously declared dependencies. This works recursively. In addition, avtomat reads dependency files generated by gcc, so includes are always checked when deciding if a file needs to be recompiled.

- **Multi-source generators**: when using a script or binary to generate files, more than one source can be specified to trigger regeneration. Whereas `dst:gen*` runs `gen` to create `dst` when `gen` is updated, the variant `dst:[gen*,src0,srcN]` also checks the listed sources. The `%` modulo operator can be used as a wildcard character for triggering a search across the entire project.

- **Copy machine**: files to be copied into the local `bin`,`lib` or `include` (relative to project `root`) for later reuse can be specified through `XCPY`,`LCPY` and `HCPY`, respectively; copies are made only when the original file is updated.

# USAGE[0]

I like having one big directory and all related projects within, so naturally I made avtomat to work with that kind of setup. Thus, that's what you have to deal with.

But it's actually pretty simple. Your top directory, the one containing your projects, is the `root`. Your folder structure should look like this:

```
root
|->project_0
|->project_N
|->bin
|->lib
|->include
|->trashcan
|.avto-modules
|.avto-config
```

The project folders are up to you, everything else is generated; `lib`, `bin`,`include` and `trashcan` are created if they don't exist and entirely managed by avtomat, and then the `.avto-*` files are used to make build scripts.

Notice the infamous `trashcan` dir. This one mirrors the file structure of your projects, but stores object, dependency and disassembly files rather than sources; effectively, this means you do not need to worry so much about build clutter in your source directories, or look up `-Wa,-a=*` in a gcc man page whenever you want to read into what the compiler is doing.

Speaking of generated assembly, avtomat uses flags that optimize for code size. I do not know many people that even bother tweaking compiler flags, or even looking into what they do for that matter, so they are simply hard-coded to my personal preferences. If this offends you greatly, then you're already the kind of person that can simply go into `avt.pm`, find `sub make {` and scroll down to this bit:

```
my $OFLG='-s -Os -fno-unwind-tables '.
  '-fno-asynchronous-unwind-tables '.
  '-ffast-math -fsingle-precision-constant '.
  '-fno-ident';

my $LFLG=$OFLG.' -flto -ffunction-sections '.
  '-fdata-sections -Wl,--gc-sections '.
  '-Wl,-fuse-ld=bfd';
```

Where you, basically, can set whichever flags you like. Then if those malfunction, it's on you!

# USAGE[1]

Now that you (hopefully) have a top directory with projects inside, it's time to call avtomat. The invocation goes as such:

```
avtomat <root> <task> [<items>]

```

Where `root` is your top level directory, and `task` is one of `scan`,`config` or `make`.

`scan` reads the subdirectories listed in `items`, which takes the form `item0 itemN`; it's space-separated elements. The `-x <dir>` or `--exclude=dir` switch can be used to skip certain directories while scanning. `item0 -x sub itemN` excludes `sub` from `item0` but not `itemN`.

`config` sets build options for modules matching `item0 item0_config itemN itemN_config`; `make` then emits a makefile according to the set config. Now, whereas `make` doesn't need any items being passed to it, `config` does and it's slightly involved. Don't worry, I'll explain.

# CONFIG FILES

For `config`, `items` is a `module build_options` pair; `module` is simply the directory name of your project, and `build_options` is made of lists of comma-separated items, each separated by a single space:

```
BUILD XCPY LCPY HCPY GENS LIBS INCL DEFS

```

Let's unpack that.

- `BUILD` takes the form `mode:out`, where `mode` is one of `x|so|l`: executable, shared object and static library, respectively, and `out` is just the name you want to call the resulting binary. This option is only important for modules with code that requires compilation
- `XCPY`,`LCPY` and `HCPY`, as previously discussed, are lists of either scripts or pre-compiled binaries that already live within the module folder and must be copied to the local `bin`,`lib` or `include`, relative to the project folder
- `GENS` lists scripts or binaries that must be run to generate a dependency; these are always run *before* compilation. Like pointed out many paragraphs ago, the format is `dst:gen*`, where `dst` is the file to be generated and `gen*` is the name of the executable that generates it. The variant `dst:[gen*,src0,srcN]` checks the additional files when deciding on regeneration.
- `LIBS` lists both additional library search directories and the libraries themselves
- `INCL` is for additional search paths, mainly used to find headers
- Finally, `DEFS` is for macro definitions; I was going to use it for modifying the build environment, but I have not implemented it due to absolutely everyone's distaste for macros, sadface

Processing of each of these lists can be skipped by passing them as a single `.` dot. Note that the `lib` and `include` folders relative to the project directory will always be used, so do not specify them.

Furthermore, for `LIBS` and `INCL` you musn't pass `-L`, `-l` or `-I` switches; all your paths must contain at least a single `/` slash so that they can be identified as proper paths; the `.` dot, `~` (ascii)tilde and `..` two dots work as you'd expect in handling relative paths.

For an example script that sets up a project, refer to the `AR-install` file provided with avtomat.

# FINAL NOTES (BEWARE!)

Files generated by avtomat and avt, as well as headers, version prints and related notices include this bit by default:

```perl
'Copyleft '.$AUTHOR.' '.$YEAR.'; Licensed under GNU GPL3';
```

Which means that if you do not agree with the license you will have to do the legal homework yourself, as I very much do not care for non-free software and the spooky capitalist courtroom culture as a whole.

Honestly, though? Just be a bro and inherit; repent your sins, spread GPL.
