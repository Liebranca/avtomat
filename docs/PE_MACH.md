# THE PESO MACHINE

## SYNOPSIS

(WIP) Formal description of a virtual machine.

## FOREWORD

The reason for the existance of `Mach` owes to the peculiar program trees generated by `Grammar`-derived parsers.

These trees are themselves programs right from the parsing step, as `Grammar` works by pairing syntax matches to multiple stages of code execution; it was only natural to couple such a tree with an auxiliary container to handle common tasks that require the maintenance of some contextual data, ie *global state*, such as value reads or macro expansions.

Likewise, making it so multiple trees can share the same state was born out of a similar, organic process: allowing a parse tree to recurse simplifies a handful of operations when dealing with complex, nested patterns, and having access to certain contextual data at each level of recursion in turn allows for more informed decisions to be made when solving the exact semantics of the parsed tokens.

However, the jump from 'auxiliary container' to 'virtual machine', though still a natural progression when looked at surface level, is a much more pronounced transition.

For one, a 'box' on which the programs themselves can run rather than be coupled to is an incredibly attractive idea, but we have no real need of a faithful recreation of any particular system -- merely achieving the same effect is sufficient.

And so, what we're looking at is a shallow simulation: though wholly fascinating, building an *emulator* is in this case altogether unnecessary, much more work, less convenient, and guaranteed to perform worse -- what we require is a general purpose abstraction, not a true to life replica.

## COMPONENTS

As mentioned, this purely a software construct, imitating a generously high-level view of a computer. Thus, we can define it in looser terms by naming it's foremost classes:

* `Mem`: a nested array of strings, unifying registers, stack and heap under a single abstraction.

* `Ptr`: a __labeled__ section of memory, always corresponding to a locatable address within an existing `Mem` instance.

* `Value`: a dynamic structure describing some data, constructed by composition of multiple types. Not *necessarily* locatable.

* `Scope`: a tree of keys, where every leaf node corresponds to a `Value` or `Ptr`, and every sub-branch to a namespace; used as index for all parse, compile and run-time symbols.
