#!/usr/bin/perl

# tests Peso Language Pattern Syntax

# ---   *   ---   *   ---
# deps
  use strict;
  use warnings;

  use lib $ENV{'ARPATH'}.'/lib/';

  use lang;
  use langdefs::plps;
  use langdefs::c;

  use peso::rd;
  use avt;

# ---   *   ---   *   ---

my $program=peso::rd::parse(

  lang->plps,
  peso::rd->FILE,

  avt::dirof(__FILE__).'/pat.pe.lps',

);

# ---   *   ---   *   ---
# program nit, avto this later

lang->plps->sbl->setdef($program);
my $SYMS=lang->plps->sbl->SYMS;

$program->{dst}=undef;
$program->{defs}={};

for my $type(keys %{lang->plps->types}) {
  $program->{defs}->{$type}={};

};

# ---   *   ---   *   ---

my $abr_h={

  'type'=>'types',
  'spec'=>'specifiers',
  'bare'=>'names',
  'ode'=>'ode',
  'cde'=>'cde',

};

# ---   *   ---   *   ---

sub getext() {

  my @tree=();
  for my $node(@{$program->{tree}}) {

    my @ar=$node->branches_in('^in$');
    if(@ar) {
      $SYMS->{$node->value}->ex($node);

    } else {push @tree,$node;};

  };$program->{tree}=\@tree;

};

# ---   *   ---   *   ---

sub detag($) {

  my $node=shift;
  my $root=$node;

  my @leaves=($node);

# ---   *   ---   *   ---

  do {

    $node=shift @leaves;

    if($node->value eq 'end') {

      my ($cath,$name)=@{$program->{dst}};
      $root->value($name);

# ---   *   ---   *   ---
# create new pattern instance from tree

      $program->{defs}->{$name}

        =bless {

          value=>[],
          attrs=>$cath,

          optional=>0,
          consume_equal=>0,
          rewind=>0,

        },'plps_obj'

      ;

    };

# ---   *   ---   *   ---

    my $tag=$abr_h->{$node->value};
    my $v=undef;
    my $attrs=undef;

    my $re=lang::cut_token_re;

# ---   *   ---   *   ---

    if(defined $tag) {
      $v=$program->{ext}->$tag;
      $attrs=$tag;

      if(lang::is_hashref($v)) {
        $v=lang::hashpat($v);

      };

# ---   *   ---   *   ---

    } elsif($node->value=~ m/${re}/) {

      $v=lang::stitch(
        $node->value,
        $program->{strings}

      );

      $v=~ s/^'//;
      $v=~ s/'$//;

      $attrs='string';

# ---   *   ---   *   ---

    } elsif(defined

        $program->{defs}
        ->{$node->value}

    ) {

      my $h=$program->{defs}->{$node->value};

      $attrs=$h->{attrs};
      $v=$h->{value};

    };

# ---   *   ---   *   ---

    if(defined $v) {

      $node->value(bless {

        value=>$v,
        attrs=>$attrs,

        optional=>0,
        consume_equal=>0,
        rewind=>0,

      },'plps_obj');

# ---   *   ---   *   ---
# replace <tag> hierarchy with object instance

      if($node->par->value eq '<') {
        $node->par->repl($node);

      };

    };

# ---   *   ---   *   ---

    unshift @leaves,@{$node->leaves};
  } while(@leaves);
};

# ---   *   ---   *   ---

getext();

for my $node(@{$program->{tree}}) {

  if(exists $SYMS->{$node->value}) {
    $SYMS->{$node->value}->ex($node);

# ---   *   ---   *   ---

  } else {

    detag($node);

    $node->collapse();
    $node->defield();

    my @ar=$node->branches_with('^end$');
    for my $leaf(@ar) {
      $leaf->pluck($leaf->leaves->[-1]);

    };

    my $name=$node->value;
    @ar=();for my $leaf(@{$node->leaves}) {
      push @ar,$leaf->value;

    };$program->{defs}->{$name}->{value}=\@ar;

  };

};

# ---   *   ---   *   ---

sub cleanup() {

  my @tree=();

  for my $node(@{$program->{tree}}) {

    my @ar=$node->branches_in('^beg$');
    if(!@ar) {
      push @tree,$node;

    };

  };$program->{tree}=\@tree;
};

# ---   *   ---   *   ---
# TODO:
#
#   > run plps_obj
#   > plps_obj tree walkthru

sub run_pattern($$) {

  my $key=shift;
  my $string=shift;

  my $obj=$program->{defs}->{$key};
  my $last=undef;

  my @pending=($obj);

  while(@pending) {

    $obj=shift @pending;
    my $pat=$obj->{value};

    if(lang::is_arrayref($pat)) {
      unshift @pending,@$pat;
      $last=$obj;

# ---   *   ---   *   ---

    } else {

      REPEAT:

      my $match=int($string=~ s/^(${pat})\s*//);

      if(!$match && !$obj->{optional}) {
        return 1;

      } elsif($match && $obj->{consume_equal}) {
        goto REPEAT;

      } elsif($match && $obj->{rewind}) {
        unshift @pending,$last;next;

      };

# ---   *   ---   *   ---

    };

  };

  return int(length $string);
};

# ---   *   ---   *   ---

cleanup();
print run_pattern('c_func_decl','static const int* var(int x,int y)')."\n";

# ---   *   ---   *   ---
1; # ret
