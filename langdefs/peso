#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

my %PESO=(

  -NAME => 'peso',
  -EXT  => '\.(pe)$',
  -HED  => '\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$',

  -MAG  => '$ program',

  -COM  => '#',

# ---   *   ---   *   ---

  -VARS =>[

    # primitives
    [0x04,eiths(

      '(char|wide|word|long)[1-9]*,'.
      'nihil,stark,signal,'

    ,1)],

    # inherents
    [0x04,eiths(

      'str,buf,ptr,fptr,wed,lis,lock,'

    ,1)],

    # simbolic constants (sblconst)
    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    # instructions
    [0x01,eiths(

      'cpy,mov,wap,'.
      'kin,sow,reap,'.

      'inc,dec,'.

      'pop,push,mem,fre,'.
      'shift,unshift,'.

      'sys,stop,exit,'.
      'entry'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(

      'jmp,jif,eif,call,ret,wait'

    ,1)],

    # directives
    [0x0D,eiths(

      'reg,rom,proc,clan,tab,atexit'

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

sub peso_cntx_non {

  my $exp=shift;

};

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>\&peso_cntx_non,

  # var blocks
  -REGS=>{},

  # ins blocks
  -PROCS=>{},

  # block families
  -CLANS=>{

    'non'=>peso::block::nit(undef,'non',0),

  },

  # local scope
  -LNAMES=>{},

);

# ---   *   ---   *   ---

# default block
$MAM{-CLAN}=$MAM{-CLANS}->{'non'};
$MAM{-DST}={

  -TYPE=>0,
  -BLK=>$MAM{-CLAN},

};

# table of execution paths
$MAM{-EXTAB}={

'{'=>[\&peso::node::ocurl,undef],
'}'=>[undef,\&peso::node::ccurl],

# ---   *   ---   *   ---

# new reg block
'reg'=>[

  undef,

  sub {

  my $node=shift;

  # get value of first grandchild
  my $name=$node
    ->leaves->[0]
    ->leaves->[0]
    ->val;

  # get dst
  my $dst=(defined $MAM{-DST}->{-BLK}->par)
    ? $MAM{-DST}->{-BLK}->par
    : $MAM{-DST}->{-BLK}
    ;

  # append new block to dst
  my $blk=$dst->nit($name,0);

  # overwrite dst
  $MAM{-DST}=$blk;

  }

],

# ---   *   ---   *   ---

$PESO{-VARS}->[0]->[1]=>[

  undef,

  sub {

    my $node=shift;
    my $dst=$MAM{-DST};

    my $key=shift;
    $key=~ s/\s+//;

# ---   *   ---   *   ---

    # fetch values from tree
    my @line=();

    { my $ref=$node->leaves;
      my @values=();
      my @names=();

      # get names of offsets
      for my $leaf(@{ $ref->[0]->leaves }) {
        push @names,$leaf->val;

      };

# ---   *   ---   *   ---

      # get values at offsets
      if(!defined $ref->[1]->leaves) {
        for(my $i=0;$i<@names;$i++) {
          push @values,0;

        };

      } else {

        for my $leaf(@{ $ref->[1]->leaves }) {

          # skip non-numeric values
          while(!($leaf->val()=~ m/[0-9]+/)) {
            $leaf=@{$leaf->leaves}[0];

          };

          if(defined $leaf) {
            push @values,$leaf->val;

          } else {
            push @values,0;

          };

        };

      };

# ---   *   ---   *   ---

      # make [name,value] ref array
      my $i=0;
      for my $name(@names) {

        my $value=(defined $values[$i])
          ? $values[$i]
          : 0
          ;

        $line[$i]=[$name,$value];$i++;

      };

    };

# ---   *   ---   *   ---

    # grow the block
    $dst->expand(\@line,$key);

  }

],

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  # open file
  my $fname=glob(shift);
  open FH,'<',$fname or die $!;

  # verify header
  my $rb=readline FH;
  if(!($rb=~ m/${ PESO{-HED}}/)) {
    printf STDERR "$fname: bad header\n";
    goto END;

  };

# ---   *   ---   *   ---

  # get expressions
  my @exps=();{
    my $rem='';

    # read file
    while($rb=readline FH) {

      # strip comments
      $rb=~ s/#.*\n?//g;

      # force single spaces
      $rb=~ s/\s+/ /sg;

      # strip newlines?
      $rb=~ s/\n+//sg;

      if(!$rb) {next;};

# ---   *   ---   *   ---

      # line ends with {;}
      if($rb=~ m/([\{\}])|;$/) {

        $rb=$rem.$rb;$rem='';
        my @ar=split m/([\{\}])|;$/,$rb;

        # separate curls
        for my $e(@ar) {

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'}';};

        };

      # multi-line expression(s)
      } else {

        my @ar=split m/([\{\}])|;/,$rb;
        my $entry=pop @ar;

        # separate curls
        for my $e(@ar) {

          if(!defined $e || !length $e) {
            next;

          };

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'\}';};

        };$rem.=$entry;
      };

# ---   *   ---   *   ---

    };

  };close FH;

# ---   *   ---   *   ---
# aliases for these patterns

  my $directive=$PESO{-KEYS}->[1]->[1];
  my $flowctl=$PESO{-KEYS}->[0]->[1];

  my $primitive=$PESO{-VARS}->[0]->[1];
  my $inherent=$PESO{-VARS}->[1]->[1];
  my $sblconst=$PESO{-VARS}->[2]->[1];

  my $instruct=$PESO{-BILTN}->[0]->[1];

  my $operator='\{|\}';
  my $number=$DICT{-GPRE}->{-NUMS}->[0]->[1];

# ---   *   ---   *   ---

  my $pat='(('.$directive.'\s+)';
  $pat.='|('.$primitive.'\s+)';

  $pat.='|('.$instruct.'\s+)';
  $pat.='|('.$flowctl.'\s+)';
  $pat.='|('.$inherent.'\s+)';

  $pat.='|('.$sblconst.'\s+)';

  $pat.='|('.$operator.'\s*)';

  #$pat.='|('.$_LUN.'*\s+)';
  #$pat.='|('.$_LUN.'*\-\>'.$_LUN.'+\s+)';

  $pat.=")*";
  my @tree=();

# ---   *   ---   *   ---

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};
    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if( !(defined $key)
    ||  (!$exp && !length $key)

    ) {next;};

    $exp=~ s/\s*(${operator}+)\s*/$1/sg;
    $exp=~ s/(\(|\[|\]|\))/ $1 /sg;

# ---   *   ---   *   ---

    # create root node
    my $root=peso::node::nit(undef,$key);

    # determine expath from key and context

    my @expath=(undef,undef);
    { my $i=0;for my $p(

        $directive,
        $flowctl,
        $primitive,
        $inherent,
        $sblconst,
        $instruct,

        $operator,

      ) {

        # get index of matching group
        my $sa=$key=~ m/${p}/;
        if($sa) {last;};$i++;

      };

# ---   *   ---   *   ---

      # fetch expath from table

      my $tab=$MAM{-EXTAB};

      if($tab) {

        my $k=($i==2)
          ? $primitive
          : $key
          ;

        $k=~ s/\s+$//;
        if(exists $tab->{$k}) {
          @expath=@{ $tab->{$k} };

        };
      };

    };

# ---   *   ---   *   ---

    if($expath[0]) {
      $expath[0]->($root,$key);

    };

# ---   *   ---   *   ---

    $exp=~ s/\s+,/,/;

    # tokenize expression
    $root->splitlv(

      '\b[^\s]+\b\s',
      $exp

    # sort tokens
    );

    $root->branch_reloc();
    $root->agroup();
    $root->subdiv();

# ---   *   ---   *   ---

    my @nums=(

      # hex conversion
      [ $DICT{-GPRE}->{-NUMS}->[0]->[1],
        \&pehexnc

      ],

      # ^bin
      [ $DICT{-GPRE}->{-NUMS}->[1]->[1],
        \&pebinnc

      ],

      # ^octal
      [ $DICT{-GPRE}->{-NUMS}->[2]->[1],
        \&peoctnc

      ],

      # decimal notation: as-is
      [ '(((\b[1-9][0-9]*|\.)+[0-9]+f?)\b)|'.
        '(\b[1-9][0-9]*\b)',

        sub {return (shift);}

      ],

    );

    $root->collapse(\@nums);

    if(!$root->{-PAR}) {
      push @tree,$root;

    };

# ---   *   ---   *   ---

    if($expath[1]) {
      $expath[1]->($root,$key);

    };

  };

# ---   *   ---   *   ---

$MAM{-DST}->setv('b',0xFF00,'wide');
$MAM{-DST}->prich();

#  for my $root(@tree) {
#    $root->prich();
#
#  };

  return;

# ---   *   ---   *   ---

  # cleanup
  END:close FH;

};

# ---   *   ---   *   ---

