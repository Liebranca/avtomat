#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

  use peso::defs;
  use peso::rd;
  use peso::ptr;
  use peso::node;
  use peso::block;
  use peso::symbol;

my %PESO=(

  -NAME=>'peso',

  -EXT=>peso::defs::ext,
  -HED=>peso::defs::hed,
  -MAG=>peso::defs::mag,
  -COM=>peso::defs::com,

# ---   *   ---   *   ---

  -VARS =>[

    # primitives
    [0x04,eiths(

      ( join '|',
        @{peso::defs::types()}

      ).'[1-9]*,'

    ,1)],

    # intrinsics
    [0x04,eiths(

      'str,buf,ptr,fptr,wed,unwed,lis,lock,'

    ,1)],

    # simbolic constants (sblconst)
    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    # instructions
    [0x01,eiths(

      ( join ',',
        keys %{peso::defs::bafa()}

      ).','.

      'mem,fre,'.
      'shift,unshift,'.

      'kin,sow,reap,'.
      'sys,stop'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(
      (join ',',keys %{peso::defs::bafc()})

    ,1)],

    # directives
    [0x0D,eiths(
      (join ',',keys %{peso::defs::bafb()})

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>'non',

  # fwd decl the execution path table
  -EXTAB=>{},

  # instruction stack
  -PROGRAM=>[],

  -NUMCON=>[

    # hex conversion
    [ $DICT{-GPRE}->{-NUMS}->[0]->[1],
      \&pehexnc

    ],

    # ^bin
    [ $DICT{-GPRE}->{-NUMS}->[1]->[1],
      \&pebinnc

    ],

    # ^octal
    [ $DICT{-GPRE}->{-NUMS}->[2]->[1],
      \&peoctnc

    ],

    # decimal notation: as-is
    [ '(((\b[1-9][0-9]*|\.)+[0-9]+f?)\b)|'.
      '(\b[1-9][0-9]*\b)',

      sub {return (shift);}

    ],

  ],

);

# ---   *   ---   *   ---

# table of execution paths
$MAM{-EXTAB}={

'{'=>[\&peso::node::ocurl,undef],
'}'=>[undef,\&peso::node::ccurl],

# ---   *   ---   *   ---

# set namespace
'clan'=>peso::symbol::nit(

  'clan','1<bare>',

  sub {

  my $inskey=shift;
  my $name=(shift)->[0];

  my $dst=peso::block::clan('non');

# ---   *   ---   *   ---

  # is not global scope/root
  my $blk;if($name ne 'non') {

    # first pass: create new block
    if(peso::block::fpass()) {
      $blk=peso::block::nit(undef,$name);

    # second pass: find block
    } else {
      $blk=peso::block::clan('non@'.$name);

    };

# ---   *   ---   *   ---

  # is global scope
  } else {$blk=$dst;};
  $MAM{-DST}=$blk;

  },

),

# ---   *   ---   *   ---

# new data block
'reg'=>peso::symbol::nit(

  'reg','1<bare>',

  sub {

  my $inskey=shift;
  my $name=(shift)->[0];

  # get dst
  my $dst=($MAM{-DST}->attrs)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

# ---   *   ---   *   ---

  my $blk;

  # append new block to dst on first pass
  if(peso::block::fpass()) {
    $blk=$dst->nit(
      $name,peso::block->O_RDWR,

    );

  # second pass: look for block
  } else {
    $blk=peso::ptr::fetch($name)->blk;

  };

# ---   *   ---   *   ---
# overwrite dst

  $MAM{-DST}=$blk;
  peso::block::setscope($blk);

  }

),

# ---   *   ---   *   ---

# new code block
'proc'=>peso::symbol::nit(

  'proc','1<bare>',

  sub {

  my $inskey=shift;
  my $name=(shift)->[0];

  # get dst
  my $dst=($MAM{-DST}->attrs)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

# ---   *   ---   *   ---

  my $blk;

  # append new block to dst on first pass
  if(peso::block::fpass()) {
    $blk=$dst->nit(
      $name,peso::block->O_EX,

    );

  # second pass: look for block
  } else {
    $blk=peso::ptr::fetch($name)->blk;

  };

# ---   *   ---   *   ---
# overwrite dst

  $MAM{-DST}=$blk;

  }

),

# ---   *   ---   *   ---

$PESO{-VARS}->[0]->[1]=>peso::symbol::nit(

  'value_decl','-1<ptr|bare>:*-1<ptr|bare>',

  sub {

  my $inskey=shift;

  my $names=shift;
  my $values=shift;

  my $dst=$MAM{-DST};

  my $skey=undef;
  my $intrinsic=$PESO{-VARS}->[1]->[1];

# ---   *   ---   *   ---

  if($inskey=~ s/${intrinsic}//) {
    my $ins=$1;

    if($ins eq 'ptr') {
      $skey='unit';

    };
  };

  $inskey=~ s/\s+$//;

  my $wed=peso::ptr::wed('get');
  peso::ptr::wed($inskey);

# ---   *   ---   *   ---
# fill out values with zeroes if need

  my @line=();

  if(!defined $values) {

    $values=[];

    for(my $i=0;$i<@$names;$i++) {
      push @$values,0;

    };

  };

# ---   *   ---   *   ---
# make [name,value] ref array

  my $i=0;
  for my $name(@$names) {

    my $value=(defined $values->[$i])
      ? $values->[$i]
      : 0
      ;

    $line[$i]=[$name,$value];$i++;

  };

# ---   *   ---   *   ---
# alternate storage type

  if(defined $skey) {
    $inskey=$skey;

  };peso::ptr::wed($inskey);

# ---   *   ---   *   ---
# grow block on first pass

  if(peso::block::fpass()) {

    # grow the block
    $dst->expand(\@line,$inskey);

# ---   *   ---   *   ---
# initialize/overwrite values on second pass

  } else {

    for my $pair(@line) {

      my $ptr=$pair->[0];
      my $value=$pair->[1];

      peso::ptr::fetch($ptr)->setv($value);

    };

  };peso::ptr::wed($wed);

  },

),

# ---   *   ---   *   ---

'inc'=>[

  undef,
  sub {

  my $node=shift;

  sop_ari(

    $node,1,
    sub {return (shift)+(shift);}

  );

  },

],

# ---   *   ---   *   ---

'dec'=>[

  undef,
  sub {

  my $node=shift;

  sop_ari(

    $node,1,
    sub {return (shift)-(shift);}

  );

  },

],

# ---   *   ---   *   ---

'clr'=>[

  undef,
  sub {

  my $node=shift;

  sop_ari(

    $node,'self',
    sub {return (shift)^(shift);}

  );

  },

],

# ---   *   ---   *   ---

'wed'=>peso::symbol::nit(

  'wed','1<bare>',
  sub {

  my $inskey=shift;
  my $type=shift;

  peso::ptr::wed($type);

  },

),

# ---   *   ---   *   ---

'unwed'=>peso::symbol::nit(

  'unwed','0',
  sub {

  my $inskey=shift;
  my $type=shift;

  peso::ptr::wed(undef);

  },

),

# ---   *   ---   *   ---

'push'=>[

  undef,
  sub {

  my $node=shift;
  my $op0=$node->group(0,0);

  peso::block::treesolve($op0);
  peso::block::spush($op0->val);

  },

],

'pop'=>[

  undef,
  sub {

  my $node=shift;

  my $op0=$node->group(0,0);
  my $op1=$node->group(0,1);

  peso::block::treesolve($op0);
  my $v=peso::block::spop();

  if($op0->val) {

    my $ptr=peso::block::getloc(
      undef,$op0->val

    );peso::block::setv(
      undef,$ptr,$v

    );

  };

  },

],

# ---   *   ---   *   ---

'jmp'=>peso::symbol::nit(

  'jmp','1<ptr>',

  sub {

  my $inskey=shift;
  my $ptr=(shift)->[0];

  # set instruction index to ptr loc
  peso::block::setnxins(
    peso::ptr::fetch($ptr)->blk->insid

  );

  },

),

# ---   *   ---   *   ---

'entry'=>peso::symbol::nit(

  'entry','1<bare>',

  sub {

  my $inskey=shift;
  my $name=(shift)->[0];

  peso::block::entry($name);

  },

),

# ---   *   ---   *   ---

'exit'=>peso::symbol::nit(

  'exit','1<ptr|bare>',

  sub {

  my $inskey=shift;
  my $val=(shift)->[0];

  # placeholder!
  printf sprintf "Exit code <0x%.2X>\n",$val;
  peso::block::setnxins(-2);

  },

),

# ---   *   ---   *   ---

'cpy'=>peso::symbol::nit(

  'cpy','2<ptr|bare,ptr|bare>',
  sub {

  my $inskey=shift;
  my $field=shift;

  my ($dst,$src)=@$field;

  if(peso::ptr::valid($src)) {
    $src=$src->addr;

  };if(!peso::ptr::valid($dst)) {
    $dst=peso::ptr::fetch($dst);

  };$dst->setv($src);

  }

),

};

# ---   *   ---   *   ---

# single operand, arithmetic
sub sop_ari {

    my $node=shift;

    my $v0=undef;
    my $v1=shift;
    my $proc=shift;

    my $op0;
    my $dst;
    my $shf=0;

    # firstborn grandchild
    my $fbgch=$node->group(0,0);

# ---   *   ---   *   ---

    # collapse tree
    peso::block::treesolve(
      $node->leaves->[0]

    );my $ptr=$fbgch->val;

    # decode ptr
    $v0=peso::block::getv(undef,$ptr);
    if($v1 eq 'self') {$v1=$v0;};

    # execute
    $v0=$proc->($v0,$v1);
    peso::block::setv(undef,$ptr,$v0);

};

# ---   *   ---   *   ---

# multiple operands, arithmetic
sub mop_ari {

  my $node=shift;
  my $deref=shift;

  my $op0=$node->group(0,0);
  my $op1=$node->group(0,1);

  peso::block::treesolve($op0);
  peso::block::treesolve($op1);

  my ($ptr0,$ptr1)=($op0->val,$op1->val);

  # decode ptr
  my $v0=peso::block::getv(undef,$ptr0);
  my $v1=peso::block::getv(undef,$ptr1);

  peso::block::setv(
    undef,$ptr0,$ptr1

  );

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  my @exps=@{peso::rd::file(shift)};

# ---   *   ---   *   ---
# aliases for these patterns

  my $directive=$PESO{-KEYS}->[1]->[1];
  my $flowctl=$PESO{-KEYS}->[0]->[1];

  my $primitive=$PESO{-VARS}->[0]->[1];
  my $intrinsic=$PESO{-VARS}->[1]->[1];
  my $sblconst=$PESO{-VARS}->[2]->[1];

  my $instruct=$PESO{-BILTN}->[0]->[1];

  my $operator='\{|\}';
  my $number=$DICT{-GPRE}->{-NUMS}->[0]->[1];

# ---   *   ---   *   ---

  my $pat='(('.$directive.'\s+)';
  $pat.='|('.$primitive.'\s+)';

  $pat.='|('.$instruct.'(\s+|$))';
  $pat.='|('.$flowctl.'(\s+|$))';
  $pat.='|('.$intrinsic.'(\s+|$))';

  $pat.='|('.$sblconst.'\s+)';

  $pat.='|('.$operator.'\s*)';

  #$pat.='|('.$_LUN.'*\s+)';
  #$pat.='|('.$_LUN.'*\-\>'.$_LUN.'+\s+)';

  $pat.=")*";
  my @tree=();
  my $program=$MAM{-PROGRAM};

# ---   *   ---   *   ---

  # initialize peso modules
  peso::block::gblnit($MAM{-EXTAB});
  peso::node::loadnumcon($MAM{-NUMCON});

  # use default block as root
  $MAM{-DST}=peso::block::clan('non');

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};
    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if( !(defined $key)
    ||  (!$exp && !length $key)

    ) {next;};

    $exp=~ s/\s*(${operator}+)\s*/$1/sg;
    $exp=~ s/(\(|\[|\]|\))/ $1 /sg;

# ---   *   ---   *   ---

    # create root node
    my $root=peso::node::nit(undef,$key);

    # determine expath from key and context

    my $expath=undef;
    { my $i=0;for my $p(

        $directive,
        $flowctl,
        $primitive,
        $intrinsic,
        $sblconst,
        $instruct,

        $operator,

      ) {

        # get index of matching group
        my $sa=$key=~ m/${p}/;
        if($sa) {last;};$i++;

      };

# ---   *   ---   *   ---

      # fetch expath from table

      my $tab=$MAM{-EXTAB};

      if($tab) {

        my $k=($i==2)
          ? $primitive
          : $key
          ;

        $k=~ s/\s+$//;
        if(exists $tab->{$k}) {
          $expath=$tab->{$k};

        };

      };
    };

# ---   *   ---   *   ---

    $exp=~ s/\s+,/,/;

    # tokenize expression
    $root->splitlv(

      '\b[^\s]+\b\s',
      $exp

    );

# ---   *   ---   *   ---

    # sort tokens
    $root->branch_reloc();
    $root->agroup();
    $root->subdiv();

    # solve constants
    $root->collapse();

# ---   *   ---   *   ---

    # save instructions
    if(!$root->{-PAR}) {

      push @tree,$root;

      # context swapping
      if($key=~ m/(reg|proc|clan)/) {
        $MAM{-CNTX}=$1;

      # data block or directive
      };if(

         $MAM{-CNTX} eq 'reg'
      || $key=~ m/$directive/

      ) {

        $expath->ex($root,$key);

        # save data initializer
        # run on second pass
        if($MAM{-CNTX}=~ m/reg|clan/) {

          push(
            @$program,
            [$expath,$root,$key]

          );
        };

# ---   *   ---   *   ---

      # code block
      } elsif($MAM{-CNTX} eq 'proc') {

        # initialize
        if($root->val=~ m/proc/) {
          $expath->ex($root);

        # encode instruction
        } else {

          my $ins_name=$root->val;
          my $stack_alloc=0;

          if($root->val=~ m/$primitive/) {

            $expath->ex($root);

            my $dst=$MAM{-DST};

            push(
              @$program,
              [sub {$MAM{-DST}=$dst},$root,$key]

            );

            push(
              @$program,
              [$expath,$root,$key]

            );next;

          };

          my $dst=$MAM{-DST};
          my $inum=peso::block::nxins;

          # generate identifier
          my $iname=sprintf(
            'ins_%.08i',$inum

          # get instruction id
          );my $iidex=peso::block::getinsi(
            $root->val

          );

          my @ins=([$iname,$iidex]);

# ---   *   ---   *   ---

          # encode args
          my $nname=sprintf(
            'arg_%.08i',$inum

          );my $nidex=peso::block::setnode(
            $root

          );


# ---   *   ---   *   ---

          # save encoded ins+args
          $dst->expand([
            [$iname,$iidex],
            [$nname,$nidex],

          ],'unit');

          push(
            @$program,

            [ \&peso::block::expand,

              $dst,

              [ [$iname,$iidex],
                [$nname,$nidex] ],

              'unit'

            ]
          );

        };peso::block::incnxins();

      };

    };
  };

# ---   *   ---   *   ---
# replace names with ptr references
# we only do this once all names are declared

  for my $root(@tree) {
    $root->findptrs();

  };

# ---   *   ---   *   ---
# run second pass to set values
# memory is already reserved

  peso::block::incpass();
  for my $ref(@$program) {
    my @ar=@{$ref};

    my $sym=shift @ar;
    my @args=@ar;

    if(peso::symbol::valid($sym)) {
      $sym->ex(@args);

    } else {
      $sym->(@args);

    };

  };

# ---   *   ---   *   ---
# execute and print memory

  peso::block::ex();
  peso::block::clan('non')
    ->prich();

  return;

};

# ---   *   ---   *   ---

