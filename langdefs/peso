#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

my %PESO=(

  -NAME => 'peso',
  -EXT  => '\.(pe)$',
  -HED  => '\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$',

  -MAG  => '$ program',

  -COM  => '#',

# ---   *   ---   *   ---

  -VARS =>[

    [0x04,eiths(

      '(char|wide|word|long)[0-9]*,'.
      'nihil,stark,signal,'

    ,1)],

    [0x04,eiths(

      'str,buf,ptr,wed,lis,'

    ,1)],

    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    [0x01,eiths(

      'cpy,mov,wap,'.
      'kin,sow,reap,'.

      'pop,psh,mem,fre,'.
      'skp,rew,'.

      'sys,stop,exit'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(

      'jmp,jif,eif,sys,ret,wait'

    ,1)],

    # directives
    [0x0D,eiths(

      'reg,rom,proc,clan,entry,exit,atexit'

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

sub peso_cntx_non {

  my $exp=shift;

};

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>\&peso_cntx_non,

  -DST=>undef,
  -CLAN=>'def',

  # var blocks
  -REGS=>{},

  # ins blocks
  -PROCS=>{},

  # block families
  -CLANS=>{
    'def'=>{-BLOCKS=>[]}

  },

# ---   *   ---   *   ---
# leaps and such

  -SIZES=>{

    # primitives
    'char'=>1,
    'wide'=>2,
    'word'=>4,
    'long'=>8,

# ---   *   ---   *   ---
# granularity

    # ptr size
    'unit'=>0x0008,

    # pointers align to line
    # mem buffers align to page

    'line'=>0x0010, # two units
    'page'=>0x0400, # 1024

# ---   *   ---   *   ---
# function types

    'nihil'=>8,     # void(*nihil)(void)
    'stark'=>8,     # void(*stark)(void*)

    'signal'=>8,    # int(*signal)(int)

  },

# ---   *   ---   *   ---

  -CALC=>[],
  -CALC_B=>[],
  -CALC_R=>[],

  -OPS=>{

    '+'=>[2,\&ll::add],
    '-'=>[2,\&ll::sub0],

    '*'=>[2,\&ll::mul],
    '/'=>[2,\&ll::div],

    '<'=>[2,\&ll::lt0],
    '>'=>[2,\&ll::gt0],

    '<<:'=>[2,\&ll::out],
    '>>:'=>[2,\&ll::in],

    '('=>[2,\&ll::oparn],
    ')'=>[2,\&ll::cparn],

    '['=>[2,\&ll::obrak],
    ']'=>[2,\&ll::cbrak],

    '{'=>[2,\&ll::ocurl],
    '}'=>[2,\&ll::ccurl],

    '?'=>[1,\&ll::quest],
    '!'=>[1,\&ll::neg],

  },

);

# ---   *   ---   *   ---
# sloppy math

# in: arr
# save tokens to calc stack
sub peso_calcus_psh {

  my @stk=@_;

  my $i=0;for my $sym(@stk) {

    if(!defined $sym) {next}
    elsif(!(length $sym)) {next;};

    push @{ $MAM{-CALC} },$sym;

    if(exists $MAM{-OPS}->{$sym}) {

      my @ar=@{ $MAM{-CALC} };

      if($#ar<1) {goto INC;};

      ( $ar[$i],
        $ar[$i-1]

      )=ll::wap(
        $ar[$i],
        $ar[$i-1]

      );

      @{ $MAM{-CALC} }=@ar;

    };INC:$i++;
};

# ---   *   ---   *   ---

# in: str
# solves operation
};sub peso_calcus_collapse {

  # the undef chk
  my $s=shift;
  if(!(defined $s)) {return 0;};

  # ret value
  my $v=0;my $i=0;
  $s=~ s/\s*//gs;

  # check for operators, cut at them
  for my $op(split ':',$s) {

    # wapping push
    peso_calcus_psh( split
      m/${ DICT{-GPRE}
      ->{-OPS}->[0]->[1] }/,

      $op

# ---   *   ---   *   ---

    # iter through the sorted arr
    );while(@{ $MAM{-CALC} }) {

      my @ar=@{ $MAM{-CALC} };
      my $len=@ar-1;

      my $sym=shift @ar;

# ---   *   ---   *   ---

      if(exists $MAM{-OPS}->{$sym}) {

        my $arg=$MAM{-OPS}->{$sym}->[0];

        # push back
        if($len<$arg) {
          printf "$len<$arg\n";
          printf "pushing $MAM{-CALC}->[0] ".(join
            ',',@ar

          )."\n";

          while(@{ $MAM{-CALC} }) {

            $sym=shift @{ $MAM{-CALC} };

            if(exists $MAM{-OPS}->{$sym}) {
              unshift @{ $MAM{-CALC_B} },$sym;

            } else {
              unshift @{ $MAM{-CALC_R} },$sym;

            };
          };

          $MAM{-CALC}=[];last;

        };

# ---   *   ---   *   ---

        my @call=();
        my $sig=0;

        ($arg,$sig)=@{
          $MAM{-OPS}->{$sym}

        # $sig->[0..arg-1]
        };shift @{ $MAM{-CALC} };

      while($arg) {

          push(@call,
            shift @{ $MAM{-CALC} }

          );$arg--;

        };push @{ $MAM{-CALC_R} },$sig->(@call);

# ---   *   ---   *   ---

      } else {
        push @{ $MAM{-CALC_R} },
          shift @{ $MAM{-CALC} };

      };

    };$i++;
  };

# ---   *   ---   *   ---

  # solve tail
  my @tail=@{ $MAM{-CALC_B} };
  my @tail_v=@{ $MAM{-CALC_R} };

  while(@tail) {

      my $sym=shift @tail;
      printf "PP:$sym\n";

      if(!$sym) {next};

      my @call=();
      my ($arg,$sig)=@{
        $MAM{-OPS}->{$sym}

      };

      while($arg) {
        printf ">>$tail_v[0]\n";
        push @call,shift @tail_v;
        $arg--;

      };$v=$sig->(@call);
      push @tail_v,$v;

  };

# ---   *   ---   *   ---

  shift @tail_v;
  if(@tail_v) {
    my $rem=eval(join '+',@tail_v);
    $v+=$rem;

  };return $v;

};

# ---   *   ---   *   ---

# registers new reg block
sub peso_reg_new {

  # get reg block name
  if(my @mat=pss(

    "$_LUN*",
    undef,

    -NAME

  )) {

    # register
    my $name=$mat[0];
    $MAM{-REGS}->{$name}={};
    $MAM{-DST}=[$name,$MAM{-REGS}->{$name}];

    # set subrd func
    $MAM{-CNTX}=\&peso_reg_rd;

  };

# ---   *   ---   *   ---

# reads reg block entries
};sub peso_reg_rd {

  my $type='';
  my $name='';

  my $value=[];
  my $size=0;
  my $max_bytes=0;
  my $byte_sz=1;

# ---   *   ---   *   ---

  # get type
  if(my @mat=pss(

    $PESO{-VARS}->[0]->[1],
    undef,

    -TYPE

  )) {

    $type=$mat[0];
    $type=~ m/(\d*)/;

    # enfornce line size min of 16 bytes
    $size=($1) ? ($1+3) : $size;
    $size=($size && $size<4) ? 4 : $size;

    $max_bytes=$size**2;
    $byte_sz=$MAM{-SIZES}->{$type};

  };

# ---   *   ---   *   ---

  # get name
  if(my @mat=pss(

    "$_LUN*",
    undef,

    -NAME

  )) {$name=$mat[0];};

# ---   *   ---   *   ---

  my $v=0;
  my $cbyte=0;

  # get value(s)
  for my $x(psscsl(undef,-VALUE)) {

    $x=peso_calcus_collapse($x);
    $x=pehex($x);
    $v|=($x&((1<<($byte_sz*8)))-1)<<($cbyte*8);

    $cbyte+=$byte_sz;

    # value is an array of 64-bit units
    # thus, only push when value is at that size
    if($cbyte==$MAM{-SIZES}->{'unit'}) {
      push @$value,$v;$v^=$v;

    };

  # ... or when there's nothing left to push
  # ++ensure each array is 16-aligned
  };while((@$value%2) || $v || !(@$value)) {
    push @$value,$v;$v^=$v;

  };

  # debug
  printf "$name:\n";
  for(my $i=0;$i<@$value;$i+=2) {

    print sprintf
      "%016X %016X\n",
      $value->[$i+1],$value->[$i];

  };printf "\n";

# ---   *   ---   *   ---

#  $MAM{-DST}->[1]->{$name}=$value;
#
#  my $s=$MAM{-REGS}->{$MAM{-DST}->[0]}->{$name};
#
#  if($s) {
#    printf "\n>$name=$s\n";
#
#  };

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  # open file
  my $fname=glob(shift);
  open FH,'<',$fname or die $!;

  # verify header
  my $rb=readline FH;
  if(!($rb=~ m/${ PESO{-HED}}/)) {
    printf STDERR "$fname: bad header\n";
    goto END;

  };

# ---   *   ---   *   ---

  # get expressions
  my @exps=();{
    my $rem='';

    # read file
    while($rb=readline FH) {

      # strip comments
      $rb=~ s/#.*\n?//;

      # force single spaces
      $rb=~ s/\s+/ /;

      # strip newlines?
      $rb=~ s/\n+//;

      if(!$rb) {next;};

# ---   *   ---   *   ---

      # line ends with ;
      if($rb=~ m/;$/) {
        $rb=$rem.$rb;$rem='';
        push @exps,(split ';',$rb);

      # multi-line expression(s)
      } else {
        my @ar=split ';',$rb;
        $rem.=pop @ar;

        if(@ar) {
          $exps[0]=$rem.$exps[0];
          push @exps,@ar;

        };
      };

# ---   *   ---   *   ---

    };

  };close FH;

# ---   *   ---   *   ---

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};

    my $pat='(('.$PESO{-KEYS}->[1]->[1].'\s+)';
    $pat.='|('.$PESO{-VARS}->[0]->[1].'\s+))*';

    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if(!(defined $key)) {next;};

    if(!$exp) {next;};

    # create root node
    my $is_root=undef;
    my $root=node::nit($key,$is_root);
    $is_root=$root->{-ROOT};

    # here we split accordingly
    printf "-$key\n";
    for my $sym(split m/,|$/,$exp) {
      my $node=$root->nit($sym,$is_root);

      $is_root=$node->{-ROOT};
      printf "|-->".$node->{-VAL}."\n";

    };next;

# ---   *   ---   *   ---

    # check for context directives
    if(my @mat=pss(

      $PESO{-KEYS}->[1]->[1],
      $exp,

      -CNTX

    )) {

# ---   *   ---   *   ---

      # get match
      my $s=$mat[0];

      # run subrd func
      { 'reg'=>\&peso_reg_new,

        'proc'=>sub {;},
        'ret'=>sub {;},
        'clan'=>sub {;},

        'entry'=>sub {;},

      }->{$s}->();

# ---   *   ---   *   ---

    } else {
      $MAM{-CNTX}->();

    };clps();

  };return;

# ---   *   ---   *   ---

  # cleanup
  END:close FH;

};

# ---   *   ---   *   ---

