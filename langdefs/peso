#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

my %PESO=(

  -NAME => 'peso',
  -EXT  => '\.(pe)$',
  -HED  => '\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$',

  -MAG  => '$ program',

  -COM  => '#',

# ---   *   ---   *   ---

  -VARS =>[

    # primitives
    [0x04,eiths(

      '(char|wide|word|long)[1-9]*,'.
      'nihil,stark,signal,'

    ,1)],

    # intrinsics
    [0x04,eiths(

      'str,buf,ptr,fptr,wed,unwed,lis,lock,'

    ,1)],

    # simbolic constants (sblconst)
    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    # instructions
    [0x01,eiths(

      'cpy,mov,wap,'.
      'kin,sow,reap,'.

      'inc,dec,'.

      'pop,push,mem,fre,'.
      'shift,unshift,'.

      'sys,stop,exit,'.
      'entry'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(

      'jmp,jif,eif,call,ret,wait'

    ,1)],

    # directives
    [0x0D,eiths(

      'reg,rom,proc,clan,tab,atexit'

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>\&peso_cntx_non,

  # var blocks
  -REGS=>{},

  # ins blocks
  -PROCS=>{},

  # block families
  -CLANS=>{},

  # local scope
  -LNAMES=>{},

  # fwd decl the execution path table
  -EXTAB=>{},

);

# ---   *   ---   *   ---

# table of execution paths
$MAM{-EXTAB}={

'{'=>[\&peso::node::ocurl,undef],
'}'=>[undef,\&peso::node::ccurl],

# ---   *   ---   *   ---

# new reg block
'reg'=>[

  undef,

  sub {

  my $node=shift;

  # get value of first grandchild
  my $name=$node
    ->leaves->[0]
    ->leaves->[0]
    ->val;

  # get dst
  my $dst=(defined $MAM{-DST}->par)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

  # append new block to dst
  my $blk=$dst->nit(
    $name,0,
    peso::block->O_RDWR

  );

  # overwrite dst
  $MAM{-DST}=$blk;

  }

],

# ---   *   ---   *   ---

$PESO{-VARS}->[0]->[1]=>[

  undef,

  sub {

    my $node=shift;
    my $dst=$MAM{-DST};

    my $key=shift;

    my $intrinsic=$PESO{-VARS}->[1]->[1];

# ---   *   ---   *   ---

    if($key=~ s/${intrinsic}//) {
      my $ins=$1;

      printf ''.int(
        defined $MAM{-EXTAB}->{$ins}

      )."\n";

    };

    $key=~ s/\s+$//;

# ---   *   ---   *   ---

    # fetch values from tree
    my @line=();

    { my $ref=$node->leaves;
      my @values=();
      my @names=();

      # get names of offsets
      for my $leaf(@{ $ref->[0]->leaves }) {
        push @names,$leaf->val;

      };

# ---   *   ---   *   ---

      # get values at offsets
      if(!defined $ref->[1]) {
        for(my $i=0;$i<@names;$i++) {
          push @values,0;

        };

# ---   *   ---   *   ---

      } else {

        for my $leaf(@{ $ref->[1]->leaves }) {

          # solve non-numeric expressions
          if(!($leaf->val=~ m/[0-9]+/)) {
            refsolve($leaf,$key);

          };

# ---   *   ---   *   ---

          # numeric expression
          if(defined $leaf) {
            push @values,$leaf->val;

          # null
          } else {
            push @values,0;

          };

        };

      };

# ---   *   ---   *   ---

      # make [name,value] ref array
      my $i=0;
      for my $name(@names) {

        my $value=(defined $values[$i])
          ? $values[$i]
          : 0
          ;

        $line[$i]=[$name,$value];$i++;

      };

    };

# ---   *   ---   *   ---

    # grow the block
    $dst->expand(\@line,$key);

  }

],

# ---   *   ---   *   ---

'wed'=>[

  undef,
  sub {

    my $node=shift;
    peso::block::wed(
      $node->leaves
      ->[0]->leaves
      ->[0]->val

    );

  },

],

# ---   *   ---   *   ---

'unwed'=>[

  undef,
  sub {

    my $node=shift;
    my $key=shift;

    peso::block::unwed();

  },

],

};

# ---   *   ---   *   ---

sub refsolve {

  my $node=shift;
  my $type=shift;
  my $dst=$MAM{-DST};

  peso::block::wed($type);

  my $name=undef;
  my $cont=undef;

  if($node->val=~ m/@/) {

    my @path=split '@',$node->val;

    my $root=shift @path;
    my $blk=peso::block::clan($root);

    while(@path>1) {
      my $key=shift @path;
      if(!exists $blk->elems->{$key}) {
        printf "Block <".$blk->name.'> '.
          "has no member named '".
          $key."' (".$node->val.")\n";

        exit;

      };$blk=$blk->elems->{$key};

    };$name=$path[0];
    $cont=$blk;

# ---   *   ---   *   ---

  } elsif(

    $node->val()=~
    m/${_LUN}*/

  ) {

    if(!exists $dst->elems->{$node->val}) {
      printf "Block ".$dst->name.' '.
        "has no member named '".
        $node->val."'\n";

      exit;

    };$name=$node->val;
    $cont=$dst;

  };

  printf sprintf "%.8X\n",$cont->getptrloc($name);

  exit;

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  # open file
  my $fname=glob(shift);
  open FH,'<',$fname or die $!;

  # verify header
  my $rb=readline FH;
  if(!($rb=~ m/${ PESO{-HED}}/)) {
    printf STDERR "$fname: bad header\n";
    goto END;

  };

# ---   *   ---   *   ---

  # get expressions
  my @exps=();{
    my $rem='';

    # read file
    while($rb=readline FH) {

      # strip comments
      $rb=~ s/#.*\n//g;

      # remove indent
      $rb=~ s/^\s+//sg;

      # no spaces surrounding commas
      $rb=~ s/\s*,\s*/,/sg;

      # force single spaces
      $rb=~ s/\s+/\$:pad;>/sg;
      $rb=~ s/\$:pad;>/ /sg;

      # strip newlines
      $rb=~ s/\n+//sg;

      $rb=~ s/;\s+/;/sg;

      if(!$rb) {next;};

# ---   *   ---   *   ---

      # line ends with {;}
      if($rb=~ m/([\{\}])|;$/) {

        $rb=$rem.$rb;$rem='';

        my @ar=split m/([\{\}])|;$/,$rb;

        # separate curls
        for my $e(@ar) {

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'}';};

        };

      # multi-line expression(s)
      } else {

        my @ar=split m/([\{\}])|;/,$rb;
        my $entry=pop @ar;

        # separate curls
        for my $e(@ar) {

          if(!defined $e || !length $e) {
            next;

          };

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'\}';};

        };$rem.=$entry;
      };

# ---   *   ---   *   ---

    };

  };close FH;

# ---   *   ---   *   ---
# aliases for these patterns

  my $directive=$PESO{-KEYS}->[1]->[1];
  my $flowctl=$PESO{-KEYS}->[0]->[1];

  my $primitive=$PESO{-VARS}->[0]->[1];
  my $intrinsic=$PESO{-VARS}->[1]->[1];
  my $sblconst=$PESO{-VARS}->[2]->[1];

  my $instruct=$PESO{-BILTN}->[0]->[1];

  my $operator='\{|\}';
  my $number=$DICT{-GPRE}->{-NUMS}->[0]->[1];

# ---   *   ---   *   ---

  my $pat='(('.$directive.'\s+)';
  $pat.='|('.$primitive.'\s+)';

  $pat.='|('.$instruct.'\s+)';
  $pat.='|('.$flowctl.'\s+)';
  $pat.='|('.$intrinsic.'\s+)';

  $pat.='|('.$sblconst.'\s+)';

  $pat.='|('.$operator.'\s*)';

  #$pat.='|('.$_LUN.'*\s+)';
  #$pat.='|('.$_LUN.'*\-\>'.$_LUN.'+\s+)';

  $pat.=")*";
  my @tree=();

# ---   *   ---   *   ---

  # init default block
  $MAM{-CLANS}->{'non'}=
    peso::block::nit(undef,'non',0);

  # save as root
  $MAM{-DST}
    =$MAM{-CLAN}
    =$MAM{-CLANS}->{'non'};

# ---   *   ---   *   ---

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};
    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if( !(defined $key)
    ||  (!$exp && !length $key)

    ) {next;};

    $exp=~ s/\s*(${operator}+)\s*/$1/sg;
    $exp=~ s/(\(|\[|\]|\))/ $1 /sg;

# ---   *   ---   *   ---

    # create root node
    my $root=peso::node::nit(undef,$key);

    # determine expath from key and context

    my @expath=(undef,undef);
    { my $i=0;for my $p(

        $directive,
        $flowctl,
        $primitive,
        $intrinsic,
        $sblconst,
        $instruct,

        $operator,

      ) {

        # get index of matching group
        my $sa=$key=~ m/${p}/;
        if($sa) {last;};$i++;

      };

# ---   *   ---   *   ---

      # fetch expath from table

      my $tab=$MAM{-EXTAB};

      if($tab) {

        my $k=($i==2)
          ? $primitive
          : $key
          ;

        $k=~ s/\s+$//;
        if(exists $tab->{$k}) {
          @expath=@{ $tab->{$k} };

        };
      };

    };

# ---   *   ---   *   ---

    if($expath[0]) {
      $expath[0]->($root,$key);

    };

# ---   *   ---   *   ---

    $exp=~ s/\s+,/,/;

    # tokenize expression
    $root->splitlv(

      '\b[^\s]+\b\s',
      $exp

    # sort tokens
    );

    $root->branch_reloc();
    $root->agroup();
    $root->subdiv();

# ---   *   ---   *   ---

    my @nums=(

      # hex conversion
      [ $DICT{-GPRE}->{-NUMS}->[0]->[1],
        \&pehexnc

      ],

      # ^bin
      [ $DICT{-GPRE}->{-NUMS}->[1]->[1],
        \&pebinnc

      ],

      # ^octal
      [ $DICT{-GPRE}->{-NUMS}->[2]->[1],
        \&peoctnc

      ],

      # decimal notation: as-is
      [ '(((\b[1-9][0-9]*|\.)+[0-9]+f?)\b)|'.
        '(\b[1-9][0-9]*\b)',

        sub {return (shift);}

      ],

    );

    $root->collapse(\@nums);

    if(!$root->{-PAR}) {
      push @tree,$root;

    };

# ---   *   ---   *   ---

    if($expath[1]) {
      $expath[1]->($root,$key);

    };

  };

# ---   *   ---   *   ---

#$MAM{-DST}->setv('b',0xFF00);
#$MAM{-DST}->prich();

  for my $root(@tree) {
    $root->prich();

  };

  return;

# ---   *   ---   *   ---

  # cleanup
  END:close FH;

};

# ---   *   ---   *   ---

