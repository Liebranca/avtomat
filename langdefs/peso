#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

  use peso::defs;
  use peso::rd;
  use peso::ptr;
  use peso::node;
  use peso::block;
  use peso::symbol;

my %PESO=(

  -NAME=>'peso',

  -EXT=>peso::defs::ext,
  -HED=>peso::defs::hed,
  -MAG=>peso::defs::mag,
  -COM=>peso::defs::com,

# ---   *   ---   *   ---

  -VARS =>[

    # primitives
    [0x04,eiths(

      ( join '|',
        keys %{peso::defs::sizes()}

      ).'[1-9]*,'

    ,1)],

    # intrinsics
    [0x04,eiths(

      'str,buf,ptr,fptr,wed,unwed,lis,lock,'

    ,1)],

    # simbolic constants (sblconst)
    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    # instructions
    [0x01,eiths(

      ( join ',',
        keys %{peso::defs::bafa()}

      ).','.

      'mem,fre,'.
      'shift,unshift,'.

      'kin,sow,reap,'.
      'sys,stop'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(
      (join ',',keys %{peso::defs::bafc()})

    ,1)],

    # directives
    [0x0D,eiths(
      (join ',',keys %{peso::defs::bafb()})

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>'non',

  # fwd decl the execution path table
  -EXTAB=>{},

  # instruction stack
  -PROGRAM=>[],

  -NUMCON=>[

    # hex conversion
    [ $DICT{-GPRE}->{-NUMS}->[0]->[1],
      \&pehexnc

    ],

    # ^bin
    [ $DICT{-GPRE}->{-NUMS}->[1]->[1],
      \&pebinnc

    ],

    # ^octal
    [ $DICT{-GPRE}->{-NUMS}->[2]->[1],
      \&peoctnc

    ],

    # decimal notation: as-is
    [ '(((\b[1-9][0-9]*|\.)+[0-9]+f?)\b)|'.
      '(\b[1-9][0-9]*\b)',

      sub {return (shift);}

    ],

  ],

);

# ---   *   ---   *   ---

# table of execution paths
$MAM{-EXTAB}={

'{'=>[\&peso::node::ocurl,undef],
'}'=>[undef,\&peso::node::ccurl],

# ---   *   ---   *   ---

# set namespace
'clan'=>peso::symbol::nit(

  'clan','1<bare>',

  sub {

  my $name=shift;
  my $dst=peso::block::clan('non');

# ---   *   ---   *   ---

  # is not global scope/root
  my $blk;if($name ne 'non') {

    # first pass: create new block
    if(peso::block::fpass()) {
      $blk=peso::block::nit(undef,$name);

    # second pass: find block
    } else {
      $blk=peso::block::clan('non@'.$name);

    };

# ---   *   ---   *   ---

  # is global scope
  } else {$blk=$dst;};
  $MAM{-DST}=$blk;

  },

),

# ---   *   ---   *   ---

# new data block
'reg'=>peso::symbol::nit(

  'reg','1<bare>',

  sub {

  my $name=shift;

  # get dst
  my $dst=($MAM{-DST}->attrs)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

# ---   *   ---   *   ---

  my $blk;

  # append new block to dst on first pass
  if(peso::block::fpass()) {
    $blk=$dst->nit(
      $name,peso::block->O_RDWR,

    );

  # second pass: look for block
  } else {
    $blk=$name->blk;

  };

# ---   *   ---   *   ---
# overwrite dst

  $MAM{-DST}=$blk;
  peso::block::setscope($blk);

  }

),

# ---   *   ---   *   ---

# new code block
'proc'=>peso::symbol::nit(

  'proc','1<bare>',

  sub {

  my $name=shift;

  # get dst
  my $dst=($MAM{-DST}->attrs)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

# ---   *   ---   *   ---

  my $blk;

  # append new block to dst on first pass
  if(peso::block::fpass()) {
    $blk=$dst->nit(
      $name,peso::block->O_EX,

    );

  # second pass: look for block
  } else {
    $blk=$name->blk;

  };

# ---   *   ---   *   ---
# overwrite dst

  $MAM{-DST}=$blk;

  }

),

# ---   *   ---   *   ---

$PESO{-VARS}->[0]->[1]=>[

  undef,

  sub {

    my $node=shift;
    my $dst=$MAM{-DST};

    my $key=shift;
    my $skey=undef;

    my $intrinsic=$PESO{-VARS}->[1]->[1];

# ---   *   ---   *   ---

    if($key=~ s/${intrinsic}//) {
      my $ins=$1;

      if($ins eq 'ptr') {
        $skey='unit';

      };
    };

    $key=~ s/\s+$//;

    my $wed=peso::ptr::wed('get');
    peso::ptr::wed($key);

# ---   *   ---   *   ---

    # fetch values from tree
    my @line=();

    { my $ref=$node->leaves;
      my @values=();
      my @names=();

      # get names of offsets
      for my $leaf(@{ $ref->[0]->leaves }) {
        push @names,$leaf->val;

      };

# ---   *   ---   *   ---

      # get values at offsets
      if(!defined $ref->[1]) {
        for(my $i=0;$i<@names;$i++) {
          push @values,0;

        };

# ---   *   ---   *   ---

      } else {

        for my $leaf(@{ $ref->[1]->leaves }) {

          # solve non-numeric expressions
          if(

             !peso::block::fpass()
          && !($leaf->val=~ m/[0-9]+/)

          ) {

            peso::block::refsolve_rec($leaf);
            $leaf->collapse();

          };

# ---   *   ---   *   ---

          # numeric expression
          if(defined $leaf) {
            push @values,$leaf->val;

          # null
          } else {
            push @values,0;

          };

        };
      };

# ---   *   ---   *   ---

      # make [name,value] ref array
      my $i=0;
      for my $name(@names) {

        my $value=(defined $values[$i])
          ? $values[$i]
          : 0
          ;

        $line[$i]=[$name,$value];$i++;

      };

    };

# ---   *   ---   *   ---

    # alternate storage type
    if(defined $skey) {
      $key=$skey;

    };

    # grow the block
    $dst->expand(\@line,$key);
    peso::ptr::wed($wed);

  },

],

# ---   *   ---   *   ---

'inc'=>[

  undef,
  sub {

    my $node=shift;

    sop_ari(

      $node,1,
      sub {return (shift)+(shift);}

    );

  },

],

# ---   *   ---   *   ---

'dec'=>[

  undef,
  sub {

    my $node=shift;

    sop_ari(

      $node,1,
      sub {return (shift)-(shift);}

    );

  },

],

# ---   *   ---   *   ---

'clr'=>[

  undef,
  sub {

    my $node=shift;

    sop_ari(

      $node,'self',
      sub {return (shift)^(shift);}

    );

  },

],

# ---   *   ---   *   ---

'wed'=>[

  undef,
  sub {

    my $node=shift;
    peso::ptr::wed($node->group(0,0)->val);

  },

],

# ---   *   ---   *   ---

'unwed'=>[

  undef,
  sub {

    my $node=shift;
    peso::ptr::wed(undef);

  },

],

# ---   *   ---   *   ---

'push'=>[

  undef,
  sub {

  my $node=shift;
  my $op0=$node->group(0,0);

  peso::block::treesolve($op0);
  peso::block::spush($op0->val);

  },

],

'pop'=>[

  undef,
  sub {

  my $node=shift;

  my $op0=$node->group(0,0);
  my $op1=$node->group(0,1);

  peso::block::treesolve($op0);
  my $v=peso::block::spop();

  if($op0->val) {

    my $ptr=peso::block::getloc(
      undef,$op0->val

    );peso::block::setv(
      undef,$ptr,$v

    );

  };

  },

],

# ---   *   ---   *   ---

'jmp'=>peso::symbol::nit(

  'jmp','1<ptr>',

  sub {

    # set instruction index to ptr loc
    my $ptr=shift;
    peso::block::setnxins(
      $ptr->blk->insid

    );

  },

),

# ---   *   ---   *   ---

'entry'=>peso::symbol::nit(

  'entry','1<bare>',

  sub {

  my $name=shift;
  peso::block::entry($name);

  },

),

# ---   *   ---   *   ---

'exit'=>peso::symbol::nit(

  'exit','1<bare|ptr>',

  sub {

    my $val=shift;

    # placeholder!
    printf sprintf "Exit code <0x%.2X>\n",$val;
    peso::block::setnxins(-2);

  },

),

# ---   *   ---   *   ---

'cpy'=>[

  undef,
  sub {

  my $node=shift;
  mop_ari($node,[0,1]);

  }

],

};

# ---   *   ---   *   ---

# single operand, arithmetic
sub sop_ari {

    my $node=shift;

    my $v0=undef;
    my $v1=shift;
    my $proc=shift;

    my $op0;
    my $dst;
    my $shf=0;

    # firstborn grandchild
    my $fbgch=$node->group(0,0);

# ---   *   ---   *   ---

    # collapse tree
    peso::block::treesolve(
      $node->leaves->[0]

    );my $ptr=$fbgch->val;

    # decode ptr
    $v0=peso::block::getv(undef,$ptr);
    if($v1 eq 'self') {$v1=$v0;};

    # execute
    $v0=$proc->($v0,$v1);
    peso::block::setv(undef,$ptr,$v0);

};

# ---   *   ---   *   ---

# multiple operands, arithmetic
sub mop_ari {

  my $node=shift;
  my $deref=shift;

  my $op0=$node->group(0,0);
  my $op1=$node->group(0,1);

  peso::block::treesolve($op0);
  peso::block::treesolve($op1);

  my ($ptr0,$ptr1)=($op0->val,$op1->val);

  # decode ptr
  my $v0=peso::block::getv(undef,$ptr0);
  my $v1=peso::block::getv(undef,$ptr1);

  peso::block::setv(
    undef,$ptr0,$ptr1

  );

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  my @exps=@{peso::rd::file(shift)};

# ---   *   ---   *   ---
# aliases for these patterns

  my $directive=$PESO{-KEYS}->[1]->[1];
  my $flowctl=$PESO{-KEYS}->[0]->[1];

  my $primitive=$PESO{-VARS}->[0]->[1];
  my $intrinsic=$PESO{-VARS}->[1]->[1];
  my $sblconst=$PESO{-VARS}->[2]->[1];

  my $instruct=$PESO{-BILTN}->[0]->[1];

  my $operator='\{|\}';
  my $number=$DICT{-GPRE}->{-NUMS}->[0]->[1];

# ---   *   ---   *   ---

  my $pat='(('.$directive.'\s+)';
  $pat.='|('.$primitive.'\s+)';

  $pat.='|('.$instruct.'(\s+|$))';
  $pat.='|('.$flowctl.'(\s+|$))';
  $pat.='|('.$intrinsic.'(\s+|$))';

  $pat.='|('.$sblconst.'\s+)';

  $pat.='|('.$operator.'\s*)';

  #$pat.='|('.$_LUN.'*\s+)';
  #$pat.='|('.$_LUN.'*\-\>'.$_LUN.'+\s+)';

  $pat.=")*";
  my @tree=();
  my $program=$MAM{-PROGRAM};

# ---   *   ---   *   ---

  # initialize peso modules
  peso::block::gblnit($MAM{-EXTAB});
  peso::node::loadnumcon($MAM{-NUMCON});

  # use default block as root
  $MAM{-DST}=peso::block::clan('non');

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};
    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if( !(defined $key)
    ||  (!$exp && !length $key)

    ) {next;};

    $exp=~ s/\s*(${operator}+)\s*/$1/sg;
    $exp=~ s/(\(|\[|\]|\))/ $1 /sg;

# ---   *   ---   *   ---

    # create root node
    my $root=peso::node::nit(undef,$key);

    # determine expath from key and context

    my $expath=undef;
    { my $i=0;for my $p(

        $directive,
        $flowctl,
        $primitive,
        $intrinsic,
        $sblconst,
        $instruct,

        $operator,

      ) {

        # get index of matching group
        my $sa=$key=~ m/${p}/;
        if($sa) {last;};$i++;

      };

# ---   *   ---   *   ---

      # fetch expath from table

      my $tab=$MAM{-EXTAB};

      if($tab) {

        my $k=($i==2)
          ? $primitive
          : $key
          ;

        $k=~ s/\s+$//;
        if(exists $tab->{$k}) {
          $expath=$tab->{$k};

        };

      };
    };

# ---   *   ---   *   ---

    $exp=~ s/\s+,/,/;

    # tokenize expression
    $root->splitlv(

      '\b[^\s]+\b\s',
      $exp

    );

# ---   *   ---   *   ---

    # sort tokens
    $root->branch_reloc();
    $root->agroup();
    $root->subdiv();

    # solve constants
    $root->collapse();

# ---   *   ---   *   ---

    # save instructions
    if(!$root->{-PAR}) {

      push @tree,$root;

      # context swapping
      if($key=~ m/(reg|proc|clan)/) {
        $MAM{-CNTX}=$1;

      # data block or directive
      };if(

         $MAM{-CNTX} eq 'reg'
      || $key=~ m/$directive/

      ) {

        $expath->ex($root,$key);

        # save data initializer
        # run on second pass
        if($MAM{-CNTX}=~ m/reg|clan/) {

          push(
            @$program,
            [$expath,$root,$key]

          );
        };

# ---   *   ---   *   ---

      # code block
      } elsif($MAM{-CNTX} eq 'proc') {

        # initialize
        if($root->val=~ m/proc/) {
          $expath->ex($root);

        # encode instruction
        } else {

          my $ins_name=$root->val;
          my $stack_alloc=0;

          if($root->val=~ m/$primitive/) {

            $expath->ex($root);

            my $dst=$MAM{-DST};

            push(
              @$program,
              [sub {$MAM{-DST}=$dst},$root,$key]

            );

            push(
              @$program,
              [$expath,$root,$key]

            );next;

          };

          my $dst=$MAM{-DST};
          my $inum=peso::block::nxins;

          # generate identifier
          my $iname=sprintf(
            'ins_%.08i',$inum

          # get instruction id
          );my $iidex=peso::block::getinsi(
            $root->val

          );

          my @ins=([$iname,$iidex]);

# ---   *   ---   *   ---

          # encode args
          my $nname=sprintf(
            'arg_%.08i',$inum

          );my $nidex=peso::block::setnode(
            $root

          );


# ---   *   ---   *   ---

          # save encoded ins+args
          $dst->expand([
            [$iname,$iidex],
            [$nname,$nidex],

          ],'unit');

          push(
            @$program,

            [ \&peso::block::expand,

              $dst,

              [ [$iname,$iidex],
                [$nname,$nidex] ],

              'unit'

            ]
          );

        };peso::block::incnxins();

      };

    };
  };

# ---   *   ---   *   ---
# replace names with ptr references
# we only do this once all names are declared

  for my $root(@tree) {
    $root->findptrs();

  };

# ---   *   ---   *   ---
# run second pass to set values
# memory is already reserved

  peso::block::incpass();
  for my $ref(@$program) {
    my @ar=@{$ref};

    my $sym=shift @ar;
    my @args=@ar;

    if(peso::symbol::valid($sym)) {
      $sym->ex(@args);

    } else {
      $sym->(@args);

    };

  };

# ---   *   ---   *   ---
# execute and print memory

  peso::block::ex();
  peso::block::clan('non')
    ->prich();

  return;

};

# ---   *   ---   *   ---

