#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

my %PESO=(

  -NAME => 'peso',
  -EXT  => '\.(pe)$',
  -HED  => '\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$',

  -MAG  => '$ program',

  -COM  => '#',

# ---   *   ---   *   ---

  -VARS =>[

    # primitives
    [0x04,eiths(

      '(char|wide|word|long)[1-9]*,'.
      'nihil,stark,signal,'

    ,1)],

    # intrinsics
    [0x04,eiths(

      'str,buf,ptr,fptr,wed,unwed,lis,lock,'

    ,1)],

    # simbolic constants (sblconst)
    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    # instructions
    [0x01,eiths(

      'cpy,mov,wap,'.
      'kin,sow,reap,'.

      'inc,dec,cl,'.

      'pop,push,mem,fre,'.
      'shift,unshift,'.

      'sys,stop,exit'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(

      'jmp,jif,eif,call,ret,wait'

    ,1)],

    # directives
    [0x0D,eiths(

      'reg,rom,proc,clan,tab,atexit,entry'

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>'non',

  # fwd decl the execution path table
  -EXTAB=>{},

  # instruction stack
  -PROGRAM=>[],

  -NUMCON=>[

    # hex conversion
    [ $DICT{-GPRE}->{-NUMS}->[0]->[1],
      \&pehexnc

    ],

    # ^bin
    [ $DICT{-GPRE}->{-NUMS}->[1]->[1],
      \&pebinnc

    ],

    # ^octal
    [ $DICT{-GPRE}->{-NUMS}->[2]->[1],
      \&peoctnc

    ],

    # decimal notation: as-is
    [ '(((\b[1-9][0-9]*|\.)+[0-9]+f?)\b)|'.
      '(\b[1-9][0-9]*\b)',

      sub {return (shift);}

    ],

  ],

);

# ---   *   ---   *   ---

# table of execution paths
$MAM{-EXTAB}={

'{'=>[\&peso::node::ocurl,undef],
'}'=>[undef,\&peso::node::ccurl],

# ---   *   ---   *   ---

# new data block
'reg'=>[

  undef,

  sub {

  my $node=shift;

  # get value of first grandchild
  my $name=$node
    ->leaves->[0]
    ->leaves->[0]
    ->val;

  # get dst
  my $dst=(defined $MAM{-DST}->par)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

# ---   *   ---   *   ---

  my $blk;

  # append new block to dst on first pass
  if(peso::block::fpass()) {
    $blk=$dst->nit(
      $name,peso::block->O_RDWR,

    );

  # second pass: look for block
  } else {
    $blk=peso::block::bgetptrv(
      undef,$dst->ances."\@$name"

    );
  };

  # overwrite dst
  $MAM{-DST}=$blk;
  peso::block::setscope($blk);

  }

],

# ---   *   ---   *   ---

# new code block
'proc'=>[

  undef,

  sub {

  my $node=shift;

  # get value of first grandchild
  my $name=$node
    ->leaves->[0]
    ->leaves->[0]
    ->val;

  # get dst
  my $dst=(defined $MAM{-DST}->par)
    ? $MAM{-DST}->par
    : $MAM{-DST}
    ;

# ---   *   ---   *   ---

  my $blk;

  # append new block to dst on first pass
  if(peso::block::fpass()) {
    $blk=$dst->nit(
      $name,peso::block->O_EX,

    );

  # second pass: look for block
  } else {
    $blk=peso::block::bgetptrv(
      undef,$dst->ances."\@$name"

    );
  };

  # overwrite dst
  $MAM{-DST}=$blk;

  }

],

# ---   *   ---   *   ---

$PESO{-VARS}->[0]->[1]=>[

  undef,

  sub {

    my $node=shift;
    my $dst=$MAM{-DST};

    my $key=shift;
    my $skey=undef;

    my $intrinsic=$PESO{-VARS}->[1]->[1];

# ---   *   ---   *   ---

    if($key=~ s/${intrinsic}//) {
      my $ins=$1;

      if($ins eq 'ptr') {
        $skey='unit';

      };
    };

    $key=~ s/\s+$//;

    my $wed=peso::block::wed('get');
    peso::block::wed($key);

# ---   *   ---   *   ---

    # fetch values from tree
    my @line=();

    { my $ref=$node->leaves;
      my @values=();
      my @names=();

      # get names of offsets
      for my $leaf(@{ $ref->[0]->leaves }) {
        push @names,$leaf->val;

      };

# ---   *   ---   *   ---

      # get values at offsets
      if(!defined $ref->[1]) {
        for(my $i=0;$i<@names;$i++) {
          push @values,0;

        };

# ---   *   ---   *   ---

      } else {

        for my $leaf(@{ $ref->[1]->leaves }) {

          # solve non-numeric expressions
          if(!($leaf->val=~ m/[0-9]+/)) {
            peso::block::refsolve_rec($leaf);
            $leaf->collapse();

          };

# ---   *   ---   *   ---

          # numeric expression
          if(defined $leaf) {
            push @values,$leaf->val;

          # null
          } else {
            push @values,0;

          };

        };

      };

# ---   *   ---   *   ---

      # make [name,value] ref array
      my $i=0;
      for my $name(@names) {

        my $value=(defined $values[$i])
          ? $values[$i]
          : 0
          ;

        $line[$i]=[$name,$value];$i++;

      };

    };

# ---   *   ---   *   ---

    # alternate storage type
    if(defined $skey) {
      $key=$skey;

    };

    # grow the block
    $dst->expand(\@line,$key);
    peso::block::wed($wed);

  },

],

# ---   *   ---   *   ---

'inc'=>[

  undef,
  sub {

    my $node=shift;

    sop_ari(

      $node,1,
      sub {return (shift)+(shift);}

    );

  },

],

# ---   *   ---   *   ---

'dec'=>[

  undef,
  sub {

    my $node=shift;

    sop_ari(

      $node,1,
      sub {return (shift)-(shift);}

    );

  },

],

# ---   *   ---   *   ---

'cl'=>[

  undef,
  sub {

    my $node=shift;

    sop_ari(

      $node,'self',
      sub {return (shift)^(shift);}

    );

  },

],

# ---   *   ---   *   ---

'wed'=>[

  undef,
  sub {

    my $node=shift;
    peso::block::wed(
      $node->leaves
      ->[0]->leaves
      ->[0]->val

    );

  },

],

# ---   *   ---   *   ---

'unwed'=>[

  undef,
  sub {

    my $node=shift;
    peso::block::wed(undef);

  },

],

# ---   *   ---   *   ---

'jmp'=>[

  undef,
  sub {

    my $node=shift;

#    my $val
#      =$node
#      ->leaves->[0]
#      ->leaves->[0]
#      ->val;

    peso::block::treesolve($node->leaves->[0],1);

    my $ptr
      =$node
      ->leaves->[0]
      ->leaves->[0]
      ->val;

    my $blk=peso::block::clan('non');

#    my $blk=peso::block::clan('self');

# ---   *   ---   *   ---

#    if(
#
#       !exists $blk->elems->{$val}
#    && defined $blk->par
#
#    ) {
#
#      $blk=peso::block::clan('non');
#
#    };

    my $dst=$blk->bderefptr($ptr);
    peso::block::setnxins($dst->insid);

  },

],

# ---   *   ---   *   ---

'entry'=>[

  undef,
  sub {

    my $node=shift;

    my $val
      =$node->leaves->[0]
      ->leaves->[0]
      ->val;

    peso::block::entry($val);

  },

],

# ---   *   ---   *   ---

'exit'=>[

  undef,
  sub {

    my $node=shift;

    my $val
      =$node->leaves->[0]
      ->leaves->[0]
      ->val;

    # placeholder!
    printf sprintf "Exit code <0x%.2X>\n",$val;
    peso::block::setnxins(-2);

  },

],

};

# ---   *   ---   *   ---

# single operand, arithmetic
sub sop_ari {

    my $node=shift;

    my $v0=undef;
    my $v1=shift;
    my $proc=shift;

    my $op0;
    my $dst;
    my $shf=0;

    # firstborn grandchild
    my $fbgch
      =$node->leaves
      ->[0]->leaves
      ->[0];

# ---   *   ---   *   ---

    peso::block::treesolve($node,0);
    my $ptr=$fbgch->val;

# i *think* this isn't needed now
#    if($fbgch->val eq '[') {
#      $ptr=peso::block::getptrv(
#
#        undef,
#        $fbgch->leaves->[0]->val
#
#      );
#
#    } else {
#      $ptr=$fbgch->val;
#
#    };

    $v0=peso::block::getptrv(undef,$ptr);
    if($v1 eq 'self') {$v1=$v0;};

    $v0=$proc->($v0,$v1);
    peso::block::setptrv(undef,$ptr,$v0);

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  # open file
  my $fname=glob(shift);
  open FH,'<',$fname or die $!;

  # verify header
  my $rb=readline FH;
  if(!($rb=~ m/${ PESO{-HED}}/)) {
    printf STDERR "$fname: bad header\n";
    goto END;

  };

# ---   *   ---   *   ---

  # get expressions
  my @exps=();{
    my $rem='';

    # read file
    while($rb=readline FH) {

      # strip comments
      $rb=~ s/#.*\n//g;

      # remove indent
      $rb=~ s/^\s+//sg;

      # no spaces surrounding commas
      $rb=~ s/\s*,\s*/,/sg;

      # force single spaces
      $rb=~ s/\s+/\$:pad;>/sg;
      $rb=~ s/\$:pad;>/ /sg;

      # strip newlines
      $rb=~ s/\n+//sg;

      $rb=~ s/;\s+/;/sg;

      if(!$rb) {next;};

# ---   *   ---   *   ---

      # line ends with {;}
      if($rb=~ m/([\{\}])|;$|;/) {

        $rb=$rem.$rb;$rem='';

        my @ar=split m/([\{\}])|;$|;/,$rb;

        # separate curls
        for my $e(@ar) {

          if(!defined $e || !length $e) {
            next;

          };

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'}';};

        };

      # multi-line expression(s)
      } else {

        my @ar=split m/([\{\}])|;/,$rb;
        my $entry=pop @ar;

        # separate curls
        for my $e(@ar) {

          if(!defined $e || !length $e) {
            next;

          };

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'\}';};

        };$rem.=$entry;
      };

# ---   *   ---   *   ---

    };

  };close FH;

# ---   *   ---   *   ---
# aliases for these patterns

  my $directive=$PESO{-KEYS}->[1]->[1];
  my $flowctl=$PESO{-KEYS}->[0]->[1];

  my $primitive=$PESO{-VARS}->[0]->[1];
  my $intrinsic=$PESO{-VARS}->[1]->[1];
  my $sblconst=$PESO{-VARS}->[2]->[1];

  my $instruct=$PESO{-BILTN}->[0]->[1];

  my $operator='\{|\}';
  my $number=$DICT{-GPRE}->{-NUMS}->[0]->[1];

# ---   *   ---   *   ---

  my $pat='(('.$directive.'\s+)';
  $pat.='|('.$primitive.'\s+)';

  $pat.='|('.$instruct.'(\s+|$))';
  $pat.='|('.$flowctl.'(\s+|$))';
  $pat.='|('.$intrinsic.'(\s+|$))';

  $pat.='|('.$sblconst.'\s+)';

  $pat.='|('.$operator.'\s*)';

  #$pat.='|('.$_LUN.'*\s+)';
  #$pat.='|('.$_LUN.'*\-\>'.$_LUN.'+\s+)';

  $pat.=")*";
  my @tree=();
  my $program=$MAM{-PROGRAM};

# ---   *   ---   *   ---

  # use default block as root
  $MAM{-DST}=peso::block::clan('non');
  peso::block::loadins($MAM{-EXTAB});
  peso::block::setnxins(0);

  # set number covertion procs
  peso::node::loadnumcon($MAM{-NUMCON});

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};
    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if( !(defined $key)
    ||  (!$exp && !length $key)

    ) {next;};

    $exp=~ s/\s*(${operator}+)\s*/$1/sg;
    $exp=~ s/(\(|\[|\]|\))/ $1 /sg;

# ---   *   ---   *   ---

    # create root node
    my $root=peso::node::nit(undef,$key);

    # determine expath from key and context

    my @expath=(undef,undef);
    { my $i=0;for my $p(

        $directive,
        $flowctl,
        $primitive,
        $intrinsic,
        $sblconst,
        $instruct,

        $operator,

      ) {

        # get index of matching group
        my $sa=$key=~ m/${p}/;
        if($sa) {last;};$i++;

      };

# ---   *   ---   *   ---

      # fetch expath from table

      my $tab=$MAM{-EXTAB};

      if($tab) {

        my $k=($i==2)
          ? $primitive
          : $key
          ;

        $k=~ s/\s+$//;
        if(exists $tab->{$k}) {
          @expath=@{ $tab->{$k} };

        };

      };
    };

# ---   *   ---   *   ---

    if($expath[0]) {
      $expath[0]->($root,$key);

    };

# ---   *   ---   *   ---

    $exp=~ s/\s+,/,/;

    # tokenize expression
    $root->splitlv(

      '\b[^\s]+\b\s',
      $exp

    );

# ---   *   ---   *   ---

    # sort tokens
    $root->branch_reloc();
    $root->agroup();
    $root->subdiv();

    # solve constants
    $root->collapse();

# ---   *   ---   *   ---

    # save instructions
    if(!$root->{-PAR}) {

      # context swapping
      if($key=~ m/(reg|proc)/) {
        $MAM{-CNTX}=$1;

      # data block or directive
      };if(

         $MAM{-CNTX} eq 'reg'
      || $key=~ m/$directive/

      ) {

        $expath[1]->($root,$key);

        # save data initializer
        # run on second pass
        if($MAM{-CNTX} eq 'reg') {

          push(
            @$program,
            [$expath[1],$root,$key]

          );
        };

# ---   *   ---   *   ---

      # code block
      } elsif($MAM{-CNTX} eq 'proc') {

        # initialize
        if($root->val=~ m/proc/) {
          $expath[1]->($root,$key);

        # encode instruction
        } else {

          my $dst=$MAM{-DST};
          my $inum=peso::block::nxins;

          # generate identifier
          my $iname=sprintf(
            'ins_%.08i',$inum

          # get instruction id
          );my $iidex=peso::block::getinsi(
            $root->val

          );

          my @ins=([$iname,$iidex]);

# ---   *   ---   *   ---

          # encode args
          my $nname=sprintf(
            'arg_%.08i',$inum

          );my $nidex=peso::block::setnode(
            $root

          );


# ---   *   ---   *   ---

          # save encoded ins+args
          $dst->expand([
            [$iname,$iidex],
            [$nname,$nidex],

          ],'unit');

          push(
            @$program,

            [ \&peso::block::expand,

              $dst,

              [ [$iname,$iidex],
                [$nname,$nidex] ],

              'unit'

            ]
          );

        };peso::block::incnxins();

      };

    };
  };

# ---   *   ---   *   ---

  peso::block::incpass();
printf "---------\n";
  for my $ref(@$program) {
    my @ar=@{$ref};

    my $call=shift @ar;
    my @args=@ar;

    $call->(@args);

  };

# ---   *   ---   *   ---

  my $non=peso::block::clan('non');

  $non->ex();

  peso::block::clan('non')
    ->prich();

  return;

# ---   *   ---   *   ---

  # cleanup
  END:close FH;

};

# ---   *   ---   *   ---

