#!/usr/bin/perl
# ---   *   ---   *   ---
# $ syntax defs

# ---   *   ---   *   ---
#$:CUT;>

my %PESO=(

  -NAME => 'peso',
  -EXT  => '\.(pe)$',
  -HED  => '\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$\$',

  -MAG  => '$ program',

  -COM  => '#',

# ---   *   ---   *   ---

  -VARS =>[

    # primitives
    [0x04,eiths(

      '(char|wide|word|long)[0-9]*,'.
      'nihil,stark,signal,'

    ,1)],

    # inherents
    [0x04,eiths(

      'str,buf,ptr,fptr,wed,lis,lock,'

    ,1)],

    # simbolic constants (sblconst)
    [0x04,eiths(

      'self,null,non,other'

    ,1)],

  ],

# ---   *   ---   *   ---

  -BILTN =>[

    # instructions
    [0x01,eiths(

      'cpy,mov,wap,'.
      'kin,sow,reap,'.

      'pop,push,mem,fre,'.
      'skip,rew,'.

      'sys,stop,exit'

    ,1)],

  ],

# ---   *   ---   *   ---

  -KEYS =>[

    # program flow
    [0x0D,eiths(

      'jmp,jif,eif,call,ret,wait'

    ,1)],

    # directives
    [0x0D,eiths(

      'reg,rom,proc,clan,tab,entry,exit,atexit'

    ,1)],

  ],

# ---   *   ---   *   ---

);$PESO{-LCOM}=[
  [0x02,eaf($PESO{-COM},0,1)],

];$DICT{-PESO}=\%PESO;

# ---   *   ---   *   ---

sub peso_cntx_non {

  my $exp=shift;

};

# ---   *   ---   *   ---

my %MAM=(

  # subrd for current context
  -CNTX=>\&peso_cntx_non,

  -DST=>undef,
  -CLAN=>'def',

  # var blocks
  -REGS=>{},

  # ins blocks
  -PROCS=>{},

  # block families
  -CLANS=>{
    'def'=>{-BLOCKS=>[]}

  },

# ---   *   ---   *   ---
# leaps and such

  -SIZES=>{

    # primitives
    'char'=>1,
    'wide'=>2,
    'word'=>4,
    'long'=>8,

# ---   *   ---   *   ---
# granularity

    # ptr size
    'unit'=>0x0008,

    # pointers align to line
    # mem buffers align to page

    'line'=>0x0010, # two units
    'page'=>0x0400, # 1024

# ---   *   ---   *   ---
# function types

    'nihil'=>8,     # void(*nihil)(void)
    'stark'=>8,     # void(*stark)(void*)

    'signal'=>8,    # int(*signal)(int)

  },

# ---   *   ---   *   ---

  -CALC=>[],
  -CALC_B=>[],
  -CALC_R=>[],

  -OPS=>{

    '+' =>[undef,undef],
    '++'=>[undef,undef],

    '-' =>[undef,undef],
    '--'=>[undef,undef],

    '*' =>[undef,undef],
    '/' =>[undef,undef],

    '<'=>[undef,undef],
    '>'=>[undef,undef],

    '<<:'=>[undef,undef],
    '>>:'=>[undef,undef],

    '('=>[\&node::oparn,undef],
    ')'=>[undef,\&node::cparn],

    '['=>[undef,undef],
    ']'=>[undef,undef],

    '{'=>[\&node::ocurl,undef],
    '}'=>[undef,\&node::ccurl],

    '?'=>[undef,undef],
    '!'=>[undef,undef],

  },

);

# ---   *   ---   *   ---
# sloppy math

# in: arr
# save tokens to calc stack
sub peso_calcus_psh {

  my @stk=@_;

  my $i=0;for my $sym(@stk) {

    if(!defined $sym) {next}
    elsif(!(length $sym)) {next;};

    push @{ $MAM{-CALC} },$sym;

    if(exists $MAM{-OPS}->{$sym}) {

      my @ar=@{ $MAM{-CALC} };

      if($#ar<1) {goto INC;};

      ( $ar[$i],
        $ar[$i-1]

      )=ll::wap(
        $ar[$i],
        $ar[$i-1]

      );

      @{ $MAM{-CALC} }=@ar;

    };INC:$i++;
};

# ---   *   ---   *   ---

# in: str
# solves operation
};sub peso_calcus_collapse {

  # the undef chk
  my $s=shift;
  if(!(defined $s)) {return 0;};

  # ret value
  my $v=0;my $i=0;
  $s=~ s/\s*//gs;

  # check for operators, cut at them
  for my $op(split ':',$s) {

    # wapping push
    peso_calcus_psh( split
      m/${ DICT{-GPRE}
      ->{-OPS}->[0]->[1] }/,

      $op

# ---   *   ---   *   ---

    # iter through the sorted arr
    );while(@{ $MAM{-CALC} }) {

      my @ar=@{ $MAM{-CALC} };
      my $len=$#ar;

      my $sym=shift @ar;

# ---   *   ---   *   ---

      # symbol is operator
      if(exists $MAM{-OPS}->{$sym}) {

        my $arg=$MAM{-OPS}->{$sym}->[0];

        # push back if less than required args
        if($len<$arg) {

          while(@{ $MAM{-CALC} }) {

            $sym=shift @{ $MAM{-CALC} };

            if(exists $MAM{-OPS}->{$sym}) {
              unshift @{ $MAM{-CALC_B} },$sym;

            } else {
              unshift @{ $MAM{-CALC_R} },$sym;

            };
          };

          $MAM{-CALC}=[];last;

        };

# ---   *   ---   *   ---

        # get appropiate call for operator
        my @call=();
        my $sig=0;

        ($arg,$sig)=@{
          $MAM{-OPS}->{$sym}

        # $sig->[0..arg-1]
        };shift @{ $MAM{-CALC} };

# ---   *   ---   *   ---

      while($arg) {

          push(@call,
            shift @{ $MAM{-CALC} }

          );$arg--;

        };push @{ $MAM{-CALC_R} },$sig->(@call);

# ---   *   ---   *   ---

      } else {
        push @{ $MAM{-CALC_R} },
          shift @{ $MAM{-CALC} };

      };

    };$i++;
  };

# ---   *   ---   *   ---

  # solve tail
  my @tail=@{ $MAM{-CALC_B} };
  my @tail_v=@{ $MAM{-CALC_R} };

  while(@tail) {

      my $sym=shift @tail;
      printf "PP:$sym\n";

      if(!$sym) {next};

      my @call=();
      my ($arg,$sig)=@{
        $MAM{-OPS}->{$sym}

      };

      while($arg) {
        printf ">>$tail_v[0]\n";
        push @call,shift @tail_v;
        $arg--;

      };$v=$sig->(@call);
      push @tail_v,$v;

  };

# ---   *   ---   *   ---

  shift @tail_v;
  if(@tail_v) {
    my $rem=eval(join '+',@tail_v);
    $v+=$rem;

  };return $v;

};

# ---   *   ---   *   ---

# registers new reg block
sub peso_reg_new {

  # get reg block name
  if(my @mat=pss(

    "$_LUN*",
    undef,

    -NAME

  )) {

    # register
    my $name=$mat[0];
    $MAM{-REGS}->{$name}={};
    $MAM{-DST}=[$name,$MAM{-REGS}->{$name}];

    # set subrd func
    $MAM{-CNTX}=\&peso_reg_rd;

  };

# ---   *   ---   *   ---

# reads reg block entries
};sub peso_reg_rd {

  my $type='';
  my $name='';

  my $value=[];
  my $size=0;
  my $max_bytes=0;
  my $byte_sz=1;

# ---   *   ---   *   ---

  # get type
  if(my @mat=pss(

    $PESO{-VARS}->[0]->[1],
    undef,

    -TYPE

  )) {

    $type=$mat[0];
    $type=~ m/(\d*)/;

    # enfornce line size min of 16 bytes
    $size=($1) ? ($1+3) : $size;
    $size=($size && $size<4) ? 4 : $size;

    $max_bytes=$size**2;
    $byte_sz=$MAM{-SIZES}->{$type};

  };

# ---   *   ---   *   ---

  # get name
  if(my @mat=pss(

    "$_LUN*",
    undef,

    -NAME

  )) {$name=$mat[0];};

# ---   *   ---   *   ---

  my $v=0;
  my $cbyte=0;

  # get value(s)
  for my $x(psscsl(undef,-VALUE)) {

    $x=peso_calcus_collapse($x);
    $x=pehex($x);
    $v|=($x&((1<<($byte_sz*8)))-1)<<($cbyte*8);

    $cbyte+=$byte_sz;

    # value is an array of 64-bit units
    # thus, only push when value is at that size
    if($cbyte==$MAM{-SIZES}->{'unit'}) {
      push @$value,$v;$v^=$v;

    };

  # ... or when there's nothing left to push
  # ++ensure each array is 16-aligned
  };while((@$value%2) || $v || !(@$value)) {
    push @$value,$v;$v^=$v;

  };

  # debug
  printf "$name:\n";
  for(my $i=0;$i<@$value;$i+=2) {

    print sprintf
      "%016X %016X\n",
      $value->[$i+1],$value->[$i];

  };printf "\n";

# ---   *   ---   *   ---

#  $MAM{-DST}->[1]->{$name}=$value;
#
#  my $s=$MAM{-REGS}->{$MAM{-DST}->[0]}->{$name};
#
#  if($s) {
#    printf "\n>$name=$s\n";
#
#  };

};

# ---   *   ---   *   ---

# in: filename
# reads in a peso file
sub peso_rd {

  # open file
  my $fname=glob(shift);
  open FH,'<',$fname or die $!;

  # verify header
  my $rb=readline FH;
  if(!($rb=~ m/${ PESO{-HED}}/)) {
    printf STDERR "$fname: bad header\n";
    goto END;

  };

# ---   *   ---   *   ---

  # get expressions
  my @exps=();{
    my $rem='';

    # read file
    while($rb=readline FH) {

      # strip comments
      $rb=~ s/#.*\n?//g;

      # force single spaces
      $rb=~ s/\s+/ /sg;

      # strip newlines?
      $rb=~ s/\n+//sg;

      if(!$rb) {next;};

# ---   *   ---   *   ---

      # line ends with {;}
      if($rb=~ m/([\{\}])|;$/) {

        $rb=$rem.$rb;$rem='';
        my @ar=split m/([\{\}])|;$/,$rb;

        # separate curls
        for my $e(@ar) {

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'}';};

        };

      # multi-line expression(s)
      } else {

        my @ar=split m/([\{\}])|;/,$rb;
        my $entry=pop @ar;

        # separate curls
        for my $e(@ar) {

          if(!defined $e || !length $e) {
            next;

          };

          if($e=~ m/^\s*\{/) {
            push @exps,'{';
            $e=~ s/^\s*\{//;

          };my $cl=$e=~ s/\}$//;

          $e=~ s/;//;

          push @exps,$e;
          if($cl) {push @exps,'\}';};

        };$rem.=$entry;
      };

# ---   *   ---   *   ---

    };

  };close FH;

# ---   *   ---   *   ---
# aliases for these patterns

  my $directive=$PESO{-KEYS}->[1]->[1];
  my $flowctl=$PESO{-KEYS}->[0]->[1];

  my $primitive=$PESO{-VARS}->[0]->[1];
  my $inherent=$PESO{-VARS}->[1]->[1];
  my $sblconst=$PESO{-VARS}->[2]->[1];

  my $instruct=$PESO{-BILTN}->[0]->[1];

  my $operator=$DICT{-GPRE}->{-OPS}->[0]->[1];
  my $number=$DICT{-GPRE}->{-NUMS}->[0]->[1];

# ---   *   ---   *   ---

  my $pat='(('.$directive.'\s+)';
  $pat.='|('.$primitive.'\s+)';

  $pat.='|('.$instruct.'\s+)';
  $pat.='|('.$flowctl.'\s+)';
  $pat.='|('.$inherent.'\s+)';

  $pat.='|('.$sblconst.'\s+)';

  $pat.='|('.$operator.'\s*)';

  #$pat.='|('.$_LUN.'*\s+)';
  #$pat.='|('.$_LUN.'*\-\>'.$_LUN.'+\s+)';

  $pat.=")*";
  my @tree=();

# ---   *   ---   *   ---

  # iter expressions
  for my $exp(@exps) {

    if(!$exp) {next;};
    $exp=~ s/^\s*(${ pat })//;

    # first element is topmost in hierarchy
    my $key=$1;

    if( !(defined $key)
    ||  (!$exp && !length $key)

    ) {next;};

    $exp=~ s/\s*(${operator}+)\s*/$1/sg;
    $exp=~ s/(\(|\[|\]|\))/ $1 /sg;

# ---   *   ---   *   ---

    # create root node
    my $root=node::nit(undef,$key);

    # determine expath from key and context

    my @expath=(undef,undef);
    { my $i=0;for my $p(

        $directive,
        $flowctl,
        $primitive,
        $inherent,
        $sblconst,
        $instruct,

        $operator,

      ) {

        # get index of matching group
        my $sa=$key=~ m/${p}/;
        if($sa) {last;};$i++;

      };

# ---   *   ---   *   ---

      # fetch expath from table

      my $tab=(

        0,0,0,0,0,0,
        $MAM{-OPS}

      )[$i];

      if($tab) {
        my %tab=%{ $tab };

        if(exists $tab{$key}) {
          @expath=@{ $tab{$key} };

        };
      };

    };

# ---   *   ---   *   ---

    if($expath[0]) {
      $expath[0]->($root,$key);

    };

# ---   *   ---   *   ---

    $exp=~ s/\s+,/,/;

    # tokenize expression
    $root->splitlv(

      '\b[^\s]+\b\s',
      $exp

    # sort tokens
    );$root->branch_reloc();
    $root->agroup();

    $root->subdiv();

    if(!$root->{-PAR}) {
      push @tree,$root;

    };

# ---   *   ---   *   ---

    if($expath[1]) {
      $expath[1]->($root,$key);

    };

    next;

# ---   *   ---   *   ---

    # check for context directives
    if(my @mat=pss(

      $PESO{-KEYS}->[1]->[1],
      $exp,

      -CNTX

    )) {

# ---   *   ---   *   ---

      # get match
      my $s=$mat[0];

      # run subrd func
      { 'reg'=>\&peso_reg_new,

        'proc'=>sub {;},
        'ret'=>sub {;},
        'clan'=>sub {;},

        'entry'=>sub {;},

      }->{$s}->();

# ---   *   ---   *   ---

    } else {
      $MAM{-CNTX}->();

    };clps();

  };

#  for my $root(@tree) {
#    $root->prich();
#
#  };

  return;

# ---   *   ---   *   ---

  # cleanup
  END:close FH;

};

# ---   *   ---   *   ---

