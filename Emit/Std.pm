#!/usr/bin/perl
# ---   *   ---   *   ---
# EMIT STD
# common code output tools
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package Emit::Std;

  use v5.36.0;
  use strict;
  use warnings;

  use Carp qw(croak);
  use English qw(-no_match_vars);

  use lib $ENV{'ARPATH'}.'/lib/sys/';

  use Style;

  use Arstd::String;
  use Arstd::Path;
  use Arstd::IO qw(box_fstrout);

  use Shb7;


# ---   *   ---   *   ---
# info

  our $VERSION = 'v0.00.6';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# generates a notice on top of generated files

sub note($author,$ch) {
  my $t=`date +%Y`;chomp $t;
  return prepend "\n$ch ",(
    q[---   *   ---   *   ---],
    q[LIBRE BOILERPASTE],
    q[GENERATED BY AR/AVTOMAT],
    q[],
    q[LICENSED UNDER GNU GPL3],
    q[BE A BRO AND INHERIT],
    q[],
    "COPYLEFT $author $t",
    q[]
    q[---   *   ---   *   ---],

  );

};


# ---   *   ---   *   ---
# generates program info

sub version($name,$version,$author) {
  my $l1=$name.q{ v}.$version;
  my $l2='Copyleft '.$author.q{ }.`date +%Y`;
  my $l3='Licensed under GNU GPL3';

  chomp $l2;

  return box_fstrout(
    "$l1\n\n$l2\n$l3",

    fill=>'*',
    no_print=>1,

  );

};


# ---   *   ---   *   ---
# in: path to add to PATH, names to include
# returns a perl snippet as a string to be eval'd

sub reqin($path,@name) {
  return join "\n",(
    "push \@INC,$path;",
    map {"require $name;"} @name,

  );

};


# ---   *   ---   *   ---
# gets $AUTHOR from package

sub get_author($pkg) {
  no strict 'refs';
  my $out=${"$pkg\::AUTHOR"};
  return (! defined $out)
    ? 'ANON'
    : $out
    ;

};


# ---   *   ---   *   ---
# ^$VERSION

sub get_version($pkg) {
  no strict 'refs';
  my $out=${"$pkg\::VERSION"};
  return (! defined $out)
    ? 'v0.00.1b'
    : $out
    ;

};


# ---   *   ---   *   ---
# wraps over emitter output F

sub outf($emitter,$f,%O) {
  my $path = Shb7::file($f);
  my $pkg  = caller;

  $O{author}//=get_author($pkg);

  open my $fh,'+>',$path
  or croak strerr($path);

  $emitter="Emit\::$emitter";

  print {$fh} $emitter->codewrap(nxbasef($f),%O);
  close $fh or croak strerr($path);

  return;

};


# ---   *   ---   *   ---
1; # ret
