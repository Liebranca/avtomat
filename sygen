#!/usr/bin/perl
# ---   *   ---   *   ---
# SYGEN
# Creates syntax files from
# available definitions
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use strict;
  use warnings;

# ---   *   ---   *   ---

my $srcpath=$ENV{'ARPATH'}.'/avtomat';
my $dstpath=$ENV{'ARPATH'}.'/lib';

my $do_cp=0;

# first make copy
$do_cp=!(-e "$dstpath/lang.pm");
$do_cp=(!$do_cp)
  ? !((-M "$dstpath/lang.pm")
    < (-M "$srcpath/lang.pm"))

  : $do_cp
  ;

# ---   *   ---   *   ---

# check secondary deps to lib
my @files=split m/\s+/,
  `ls $srcpath/langdefs`;

if(!$do_cp) {

  my $lfold="$srcpath/langdefs";

  for my $f(@files) {

    if(

      !((-M "$dstpath/lang.pm")
      < (-M "$lfold/$f"))

    ) {$do_cp=1;last;};

  };

};

# ---   *   ---   *   ---

if($do_cp) {
  `cp $srcpath/lang.pm $dstpath/`;

};if(!(-e "$dstpath/langdefs")) {
  `mkdir -p $dstpath/langdefs`;

};

# ---   *   ---   *   ---
# iter through addons and copy if need

for my $lang(@files) {

  my $src="$srcpath/langdefs/$lang";
  my $dst="$dstpath/langdefs/$lang";

  my $up=!(-e $dst);
  $up=(!$up)

    ? !((-M $dst)
      < (-M $src))

    : $up
    ;

  if($up) {
    `cp $src $dst`;

  };
};

# ---   *   ---   *   ---

for my $lang(@files) {
  $lang=~ s/\.pm//;

};

# ---   *   ---   *   ---

sub make_script {

my $script=<<'EOF'
#!/usr/bin/perl

  use strict;
  use warnings;

  use lib $ENV{'ARPATH'}.'/lib/';

  use avt;
  use lang;

EOF
;

# ---   *   ---   *   ---

  for my $lang(@files) {
    $script.="  use langdefs::$lang;\n";

  };

# ---   *   ---   *   ---

$script.=<<'EOF'

my @colors=(

  'black','red','green','yellow',
  'blue','magenta','cyan','white',

  'grey','red','green','yellow',
  'blue','magenta','cyan','white',

);for(my $i=9;$i<16;$i++) {
  $colors[$i]='bright'.$colors[$i];

};my $FH=undef;

my %KEYCOLOR=(

  -HIER=>0x04,

  -SHCMD=>0x01,
  -PESC=>0x0E,
  -STRING=>0x0E,
  -CHAR=>0x0E,
  -PREPROC=>0x0E,

  -PFUN=>0x01,
  -NUMS=>0x03,

  -DEV0=>0x0B,
  -DEV1=>0x09,
  -DEV2=>0x66,
  -DEV3=>0x0E,

  -COMMON=>0x07,
  -NAMES_U=>0x0D,

  -TYPES=>0x04,
  -SPECIFIERS=>0x04,
  -RESNAMES=>0x04,

  -BUILTINS=>0x01,
  -INTRINSICS=>0x04,
  -DIRECTIVES=>0x0D,
  -FCTLS=>0x0D,

  -LCOM=>0x02,
  -OPS=>0x0F,
  -VSTR=>0x03,

);

my $EITHS_NOWB={

  'perl'=>{-TYPES=>1,},

};

sub prprops {

  my $def=shift;
  my $key=shift;

  my $color=$KEYCOLOR{$key};{
    my ($fg,$bg)=($color&0xF,$color>>4);
    $color=$colors[$fg].','.$colors[$bg];

  };

  my $v=$def->{$key};

  # nano syntax re was written by a degenerate
  # [\[\]] does not match square brackets

  if($key eq -OPS) {
    $v='([^\s_A-Za-z0-9]|\\\\)';

  } elsif($key eq -VSTR) {
    $v="v[0-9\.]+[ab]?";

  };

  my @ar=($v);

  if($v=~ m/^ARRAY\(0x/) {
    @ar=@{$v};

  } elsif($v=~ m/^HASH\(0x/) {

    delete $v->{re};
    my @keys=keys %{$v};
    @ar=();

# ---   *   ---   *   ---

    if(exists $EITHS_NOWB
      ->{$def->{-NAME}}
      ->{$key}

    ) {

      my @exclude=();
      my @noproc=();

      for my $elem(@keys) {
        if(!($elem=~ m/^\(+(\[\$|\\\$)/)) {
          push @exclude,$elem;

        } else {
          push @noproc,$elem;

        };

      };

      @ar=@noproc;
      @keys=@exclude;

    };

# ---   *   ---   *   ---

    for(my $x=0;$x<@keys;$x+=20) {

      my $top=(@keys>$x+19)
        ? $x+19 : $#keys;

      my @slice=(@keys[$x..$top]);
      for my $re(@slice) {
        if($re=~ m/\(\?\^u:/) {
          $re=~ s/\(\?\^u://;
          $re=~ s/\)$//;

        };

      };

      @slice=sort {
        (length $a)<=(length $b);

      } @slice;

      my $re='\b('.(join '|',@slice).')\b';

      push @ar,$re;

    };

  };

# ---   *   ---   *   ---

  for my $re(@ar) {

    $re=join '\n',(split "\n",$re);

    if($re=~ m/\(\?\^u:/s) {
      $re=~ s/\(\?\^u://s;
      $re=~ s/\)$//s;;

    };

    $re=avt::dqwrap($re);
    print $FH "color $color $re\n";

  };

};

# ---   *   ---   *   ---

sub glang {

  while(@_) {

    my $def=shift;
    my $dst=shift;

    open $FH,'>',$dst or die $!;

    my $prop='syntax '.(

      $def->{-NAME}.' "'.
      $def->ext.'"'

    )."\n";

    $prop.='header '.avt::dqwrap($def->hed)."\n";
    $prop.='magic '.avt::dqwrap($def->mag)."\n";

    $prop.='comment '.avt::dqwrap($def->com)."\n";
    print $FH "$prop\n";

# ---   *   ---   *   ---

    for my $key(

      -COMMON,-HIER,

      -NAMES_U,-PFUN,-SHCMD,-PESC,
      -BUILTINS,-FCTLS,-TYPES,-SPECIFIERS,
      -INTRINSICS,-DIRECTIVES,-RESNAMES,

      -NUMS,-VSTR,-OPS,-CHAR,-STRING,
      -PREPROC,-LCOM,-DEV0,-DEV1,-DEV2,
      -DEV3

    ) {prprops($def,$key);};
    close $FH;

  };
};

# ---   *   ---   *   ---

EOF
;

# ---   *   ---   *   ---

$script.="\nglang(\n";

for my $lang(@files) {

  $script.=
    "  lang->$lang,\n".
    "  glob(".'"'."~/.config/nano/".'".'."\n".
    "  lang->"."$lang->"."{-NAME}".
    '.".nanorc"),'."\n\n";

};$script.="\n);\n";

# ---   *   ---   *   ---

  my $ex=$ENV{'ARPATH'}.'/avtomat/ex_sygen';
  open FH,'>',$ex or die $!;


  print FH $script;
  close FH;

  `chmod +x $ex`;`$ex`;

};make_script(@files);

# ---   *   ---   *   ---
1; # ret
