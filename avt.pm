#!/usr/bin/perl

# ---   *   ---   *   ---
# AVT
# avtomat utils as a package
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb
# ---   *   ---   *   ---

# deps
package avt;
  use strict;
  use warnings;

  use Cwd qw(abs_path getcwd);

# ---   *   ---   *   ---
# info

  use constant {

    VERSION        => 2.0,
    BOXCHAR        => '.',
    CONFIG_DEFAULT => 'x . . 0',

  };

# ---   *   ---   *   ---
# global storage

  my %CACHE=(
    -ROOT       =>  '.',

  );

sub root {
  if(@_) {$CACHE{-ROOT}=abs_path(shift);};
  return $CACHE{-ROOT};

};

# ---   *   ---   *   ---
# default prints

# args=author,comment prefix
# generates a notice on top of generated files
sub note {

  my $author=shift;
  my $ch=shift;

  my $t=`date +%Y`;
  my $note=<<"EOF"
$ch ---   *   ---   *   ---
$ch LIBRE BOILERPASTE
$ch GENERATED BY AR/AVTOMAT
$ch
$ch LICENSED UNDER GNU GPL3
$ch BE A BRO AND INHERIT
$ch
$ch COPYLEFT $author $t
$ch ---   *   ---   *   ---
EOF

;return $note;

};

# args=name,version,author
# generates program info
sub version {
  my ($l1,$l2,$l3)=(
    shift.' v'.shift,
    'Copyleft '.shift.' '.`date +%Y`,
    'Licensed under GNU GPL3'

  );chomp $l2;

  my $c=BOXCHAR;
  my $version=

  ("$c"x 32)."\n".sprintf(
    "$c %-28s $c\n",$l1

  )."$c ".(' 'x 28)." $c\n".

  sprintf("$c %-28s $c\n$c %-28s $c\n",$l2,$l3).

  ("$c"x 32)."\n";

  return $version;

};

# ---   *   ---   *   ---
# C code emitter tools

# name=what your file is called
# x=1==end, 0==beg
# makes header guards
sub cboil_h {
  my $name=uc shift;
  my $x=shift;

  # header guard start
  if(!$x) {
    my $s=
'#ifndef __'.$name.'_H__'."\n".
'#define __'.$name.'_H__'."\n".
'#ifdef __cplusplus'."\n".
'extern "C" {'."\n".
'#endif'."\n"

  ;return $s;

  };my $s=
'#ifdef __cplusplus'."\n".
'};'."\n".
'#endif'."\n".
'#endif // __'.$name.'_H__'."\n"

  ;return $s;

# ---   *   ---   *   ---

# dir=where to save the file to
# fname=fname
# call=reference to a sub taking filehandle

# wraps sub in header boilerplate
};sub wrcboil_h {

  my $dir=shift;
  my $fname=shift;
  my $call=shift;

  # open boiler
  open my $FH,'>',
    $CACHE{-ROOT}.$dir.$fname.'.h' or die $!;

  print $FH avt::cboil_h uc($fname),0;

  # write the code through the generator
  $call->($FH);

  # close boiler
  print $FH avt::cboil_h uc($fname),1;
  close $FH;

};

# ---   *   ---   *   ---
# bash utils

# arg=string any
# multi-byte ord
sub mord {
  my @s=split '',shift;
  my $seq=0;
  my $i=0;while(@s) {
    $seq|=ord(shift @s)<<$i;$i+=8;

  };return $seq;
};

# ---   *   ---   *   ---

sub sqwrap {
  return "'".shift."'";

};

sub dqwrap {
  return '"'.shift.'"';

};

sub rescap {
  my $s=shift;
  $s=~ s/\*/\\\*/g;

  return $s;

};

sub ex {

  my $name=shift @_;
  my $opts=shift @_;
  my $tail=shift @_;

  my @opts=@{ $opts };

  for(my $i=0;$i<@opts;$i++) {
    if(($opts[$i]=~ m/\s/)) {
      $opts[$i]=dqwrap $opts[$i];

    };
  };

  return `$ENV{'ARPATH'}/bin/$name @opts $tail`;

};

# ---   *   ---   *   ---
# path utils

# args=chkpath,name,repo-url,actions
# pulls what you need
sub depchk {
  my ($chkpath,$deps_ref)=@_;
  $chkpath=abs_path $chkpath;

  my @deps=@{ $deps_ref };
  my $old_cwd=abs_path getcwd();chdir $chkpath;

  while(@deps) {

    my ($name,$url,$act)=@{ shift @deps };

    # pull if dir not found in provided path
    if(!(-e $chkpath."/$name")) {
      `git clone $url`;

    # blank for now, use this for building extdeps
    };if($act) {
      ;

    };

  };chdir $old_cwd;

};

# ---   *   ---   *   ---

# args=path
# recursively list dirs and files in path
sub walk {

  my %dirs=();my $path=shift;

  # dissect recursive ls
  { my @ls=split "\n\n",`ls -FBR1 $path`;
    while(@ls) {
      my @sub=split ":\n",shift @ls;

      # shorten dirnames
      $sub[0]=~ s/${ path }//;
      if(!$sub[0]) {$sub[0]='<main>';};

      # exclude hidden folders and documentation
      if( ($sub[0]=~ m/\./)
      ||  ($sub[0] eq '/docs')
      ) {next;};

      # remove ws
      $sub[1]=~ s/^\s+|\s+$//;

# ---   *   ---   *   ---

      # filter out folders and headers
      my @tmp=split "\n",$sub[1];
      my @files=();

      while(@tmp) {
        my $entry=shift @tmp;
        if(($entry=~ m/\/|.*\.h|GNUmakefile|Makefile|makefile/)) {
          next;

        };push @files,$entry;

      };

      # dirs{folder}=ref(list of files)
      $dirs{ $sub[0] }=\@files;

    };

  };return (\%dirs);

};

# ---   *   ---   *   ---

# ensures trsh and bin exist, outs file/dir list
sub scan {

  my $module_list='';
  `echo -n '' > $CACHE{-ROOT}/.avto-modules`;

  # just ensure we have these standard paths
  if(!(-e "$CACHE{-ROOT}/bin")) {
    mkdir "$CACHE{-ROOT}/bin";

  };

  if(!(-e "$CACHE{-ROOT}/lib")) {
    mkdir "$CACHE{-ROOT}/lib";

  };

  if(!(-e "$CACHE{-ROOT}/include")) {
    mkdir "$CACHE{-ROOT}/include";

  };

  if(!(-e "$CACHE{-ROOT}/trashcan")) {
    mkdir "$CACHE{-ROOT}/trashcan";

  };

# ---   *   ---   *   ---

  # iter provided names
  while(@_) {
    my $mod=shift;

    my $trsh="$CACHE{-ROOT}/trashcan/$mod";
    my $modpath="$CACHE{-ROOT}/$mod";

    # ensure there is a trashcan
    if(!(-e $trsh)) {
      system 'mkdir',('-p',"$trsh");

    };

# ---   *   ---   *   ---

    # walk module path and capture sub count
    my %h=%{ walk($modpath) };my $len=keys %h;
    `echo "$mod $len" >> $CACHE{-ROOT}/.avto-modules`;

    # paths/dir checks
    for my $sub (keys %h) {

      # ensure directores exist
      my $tsub=$sub;$tsub=~ s/${ modpath }/${ trsh }/;  
      if(!(-e $trsh)) {
        mkdir $tsub;

      };

      # capture file list
      my @files=@{ $h{$sub} };

      `echo "$sub @files" >> $CACHE{-ROOT}/.avto-modules`;

    };`touch $trsh/mklog`;

  };

};

# ---   *   ---   *   ---

# parse modules into hash
sub read_modules {

  my %h;{
    my @m=split "\n",`cat $CACHE{-ROOT}/.avto-modules`;

    # get parent name
    while(@m) {
      my ($key,$len)=split ' ',shift @m;
      my @paths;

      # store submodules as references
      while($len--) {
        my @tmp=split ' ',shift @m;
        push @paths,\@tmp;

      };

      # hash{parent}=( ($path,@files) );
      $h{$key}=\@paths;

    };
  };return \%h;

};

# ---   *   ---   *   ---

sub strconfig {
  my %config=%{ $_[0] };
  return rescap dqwrap(
    $config{'BUILD'}.' '.

    $config{'XCPY' }.' '.
    $config{'LCPY' }.' '.

    $config{'GENS' }.' '.
    $config{'LIBS' }.' '.
    $config{'INCL' }.' '.

    $config{'DEFS' }.' '

  );

};

# manages build config file
sub config {

  my %config;
  while(@_) {
    my $mod=shift @_;
    my $settings=shift @_;

    $config{$mod}=$settings;

  };

  # rewrite file
  open FH,'>',"$CACHE{-ROOT}/.avto-config" or die $!;
  for my $mod (keys %config) {
    print FH "$mod $config{$mod}\n"

  };close FH;

};

# ---   *   ---   *   ---

# emits a makefile
sub make {

  # add these directories to search path
  # ... but only if they exist, obviously

  my $base_lib=(-e $CACHE{-ROOT}.'/lib')
    ? $CACHE{-ROOT}.'/lib'
    : ''
    ;

  my $base_include=(-e $CACHE{-ROOT}.'/include')
    ? $CACHE{-ROOT}.'/include'
    : ''
    ;

# ---   *   ---   *   ---

  # fetch dir/file list
  my %modules=%{ read_modules($CACHE{-ROOT}) };

  # fetch config
  my @config=split "\n",`cat $CACHE{-ROOT}/.avto-config`;

  # now iter
  while(@config) {

    my (
      $name,
      $build,

      $xcpy,
      $lcpy,

      $gens,
      $libs,
      $incl,

      $defs

    )=split ' ',shift @config;

    my @paths=@{ $modules{$name} };

# ---   *   ---   *   ---

    # get list copy list A
    $xcpy=($xcpy ne '.')
      ? join '|',(split ',',$xcpy)
      : ''
      ;

    # get list copy list B
    $lcpy=($lcpy ne '.')
      ? join '|',(split ',',$lcpy)
      : ''
      ;

# ---   *   ---   *   ---

    while(@paths) {
      my @path=@{ shift @paths };
      my $mod=shift @path;

      # get path to
      $mod=($mod eq '<main>')
        ? $CACHE{-ROOT}."/$name"
        : $CACHE{-ROOT}."/$name/$mod"
        ;

      # copy these to bin
      if($xcpy) { my @matches=grep m/${ xcpy }/,@path;
        while(@matches) {
          my $match=shift @matches;

          if(!$xcpy) {last;};

          $xcpy=~ s/\|?${ match }\\\*\|?//;$match=~ s/\*//;
          `cp $mod/$match $CACHE{-ROOT}/bin/$match`;

        };

      };

      # copy these to lib
      if($lcpy) { my @matches=grep m/${ lcpy }/,@path;
        while(@matches) {
          my $match=shift @matches;

          if(!$lcpy) {last;};

          $lcpy=~ s/\|?${ match }\|?//;
          `cp $mod/$match $CACHE{-ROOT}/lib/$match`;

        };

      };

    };

  };

};

# ---   *   ---   *   ---
1; # ret
