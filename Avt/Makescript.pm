#!/usr/bin/perl
# ---   *   ---   *   ---
# MAKESCRIPT
# Builds your shit
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package Avt::Makescript;
  use v5.42.0;
  use strict;
  use warnings;

  use English qw($ARG);
  use Storable qw(retrieve);
  use Cwd qw(abs_path getcwd);

  use lib "$ENV{ARPATH}/lib/sys/";
  use Style qw(null);
  use Cli;
  use Log;

  use Arstd::Array qw(filter dupop);
  use Arstd::Path qw(dirof parof reqdir);
  use Arstd::Bin qw(ot moo owc);

  use Shb7::Path qw(
    root
    set_root
    relto_root
    dirp
    trashp
  );
  use Shb7::Find qw(ffind wfind);

  use Shb7::Bfile;
  use Shb7::Build;
  use Shb7::Bk::gcc;
  use Shb7::Bk::mam;
  use Shb7::Bk::flat;
  use Shb7::Bk::fake;

  use Tree::Dep;

  use Ftype::Text::C;
  use Ftype::Text::Perl;

  use lib "$ENV{ARPATH}/lib/";
  use AR;
  use Emit::Std;
  use Avt::Xcav;


# ---   *   ---   *   ---
# info

  our $VERSION = 'v0.01.7';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# ROM

my $PKG=__PACKAGE__;
St::vconst {
  CWD_RE => qr{^\./|(?<=,)\./}x,
};


# ---   *   ---   *   ---
# get bfiles of all containers

sub get_build_files($self) {
  # give full list of files to build
  return (
    $self->fasm_bfiles(),
    $self->{gcc}->bfiles(),
    $self->{mam}->bfiles(),
  );
};


# ---   *   ---   *   ---
# [DEPRECATED] get sorted bfile list
#
# NOTE:
#
# fasm headers (with the old AR/forge
# system) can't be included out of order
# as they are generated by the build itself!
#
# due to this, we have to sort this
# flist accto the dependency list

sub fasm_bfiles($self) {
  return () if ! int $self->{flat}->bfiles();
  AR::cload 'Avt::flatten';

  my @src   = $self->{flat}->bfiles();
  my %keys  = map {
    abs_path($ARG->{src})=>$ARG

  } @src;

  # ^get sorted deps that are
  # part of this compilation
  my @flatk = map {
    $ARG;

  } grep {
    exists $keys{$ARG}

  } Avt::flatten->cpproc(
    'build_deps',
    @src
  );

  # ^remove duplicates
  dupop(\@flatk);
  my @flat=map {$keys{$ARG}} @flatk;

  map {delete $keys{$ARG}} @flatk;

  # ^add remaining files
  my @rem=grep {
    exists $keys{abs_path($ARG->{src})}

  } @src;

  return (@flat,@rem);
};


# ---   *   ---   *   ---
# adjust fpath arrays

sub abspath_arr($self) {
  my $re=$PKG->CWD_RE;
  for(
    $self->{xprt},
    $self->{fcpy},
    $self->{gen},
    $self->{inc},
    $self->{lib}
  ) {
    filter $ARG;
    $ARG=~ s[$re][$self->{root}]sxmg for @$ARG;
  };

  return;
};


# ---   *   ---   *   ---
# adjust fpath strings

sub abspath_str($self) {
  my $re=$PKG->CWD_RE;
  for (
    $self->{ilib},
    $self->{mlib},
    $self->{main},
    $self->{trash},
  ) {
    $ARG=~ s[$re][$self->{root}]sxmg
    if defined $ARG;
  };

  return;
};


# ---   *   ---   *   ---
# adjust fpaths on build file objects

sub abspath_bfile($self) {
  my $re=$PKG->CWD_RE;
  for($self->get_build_files()) {
    $ARG->{src}=~ s[$re][$self->{root}]sxmg;
    $ARG->{obj}=~ s[$re][$self->{root}]sxmg;
    $ARG->{asm}=~ s[$re][$self->{root}]sxmg;
    $ARG->{out}=~ s[$re][$self->{root}]sxmg;
  };

  return;
};


# ---   *   ---   *   ---
# ^shorthand for all

sub abspaths($self) {
  $self->abspath_arr();
  $self->abspath_str();
  $self->abspath_bfile();

  return;
};


# ---   *   ---   *   ---
# cstruc

sub new($class) {
  my $self=bless {
    # name of target
    fswat => null,
    mkwat => null,

    # build file containers
    flat  => Shb7::Bk::flat->new(
      pproc=>'Avt::flatten::pproc',
    ),

    gcc   => Shb7::Bk::gcc->new(),
    mam   => Shb7::Bk::mam->new(),

    # io paths
    root  => null,
    ilib  => null,
    mlib  => null,
    main  => null,
    trash => null,

    # fpath arrays
    xprt  => [],
    fcpy  => Shb7::Bk::fake->new(),
    gen   => [],
    util  => [],
    test  => [],

    # search paths/deps
    inc  => [],
    lib  => [],

    # flags
    lmode => null,
    debug => 0,
    clean => 0,

  },$class;

  return $self;
};


# ---   *   ---   *   ---
# entry point

sub build_module($class,$file,@cmd) {
  my $dir  = dirof $file;
  my $root = parof $file;

  set_root($root);
  chdir $root;

  my $self=$class->load("$dir/.avto-cache",@cmd);
  $self->run(@cmd);

  return $self;
};


# ---   *   ---   *   ---
# makefile body

sub run($self) {
  $self->set_build_paths;
  $self->update_generated;
  $self->build_binaries($self->update_objects);
  $self->update_regular;
  $self->side_builds;

  return;
};


# ---   *   ---   *   ---
# get make config from file

sub load($class,$file,@cmd) {
  my $self=retrieve $file;
  my ($cli,@args)=$class->read_cli(@cmd);

  $self->{debug} = $cli->{debug} ne null;
  $self->{clean} = $cli->{clean} ne null;

  $self->{root}  = $Shb7::Path::Root;
  $self->{trash} = trashp($self->{fswat});

  Shb7::Path::module($self->{fswat});
  $self->abspaths();

  $self->{bld}=Shb7::Build->new(
    file    => [],
    name    => $self->{main},

    inc     => $self->{inc},
    lib     => $self->{lib},

    shared  => $self->{lmode} eq '-shared',
    debug   => $self->{debug},
    clean   => $self->{clean},
    def     => $cli->{def},

    tgt     => Shb7::Bk->target_arch()->{x64},

    linking => ($cli->{flat} ne null)
      ? 'flat'
      : 'cstd'
      ,
  );

  return $self;
};


# ---   *   ---   *   ---
# ^iface

sub read_cli($class,@cmd) {
  state @tab=(
    { id    => 'clean',
      short => '-c',
      long  => '--clean',
      argc  => 0

    },{
      id    => 'debug',
      short => '-g',
      long  => '--debug',
      argc  => 0

    },{
      id    => 'clean-debug',
      short => '-gc',
      long  => '--clean-debug',
      argc  => 0

    },{
      id      => 'def',
      short   => '-D',
      long    => '--define',
      argc    => 'array',
      default => [],

    },{
      id    => 'flat',
      short => '-f',
      long  => '--flat',
      argc  => 0
    },
  );


  # ^make ice and run
  my $cli  = Cli->new(@tab);
  my @args = $cli->take(@cmd);

  if($cli->{'clean-debug'} ne null) {
    $cli->{debug}=1;
    $cli->{clean}=1;
    delete $cli->{'clean-debug'};
  };

  # ^give
  return ($cli,@args);
};


# ---   *   ---   *   ---
# add makescript includes to
# current search path

sub set_build_paths($self) {
  my @paths=grep {
    $ARG ne "-I$Shb7::Path::Root";

  } @{$self->{inc}};

  push @paths,(dirp($self->{fswat}),'.');

  include(@paths);
  return;
};


# ---   *   ---   *   ---
# handle code generator scripts

sub update_generated($self) {
  my @GENS = @{$self->{gen}};
  my $done = 0;

  Log->step("running generators")
  if @GENS;

  # iter the list of generator scripts
  # ... and sources/dependencies for them
  for my $ref(@GENS) {
    my ($res,$gen,@msrcs)=@$ref;

    # make sure we don't need to update
    my $do_gen=(-e $res)
      ? ot($res,$gen) || $self->{clean}
      : 1
      ;

    # make damn sure we don't need to update
    if(! $do_gen) {
      while(@msrcs) {
        my $msrc=shift @msrcs;

        # look for wildcard
        if($msrc=~ Shb7::Find::wildcard_re()) {
          for my $src(wfind($msrc)) {
            # found file is updated
            if(Shb7::ot($res,$src)) {
              $do_gen=1;
              last;
            };
          };

          last if $do_gen;


        # look for specific file
        } else {
          $msrc=ffind($msrc);
          next if !$msrc;

          # found file is updated
          if(ot($res,$msrc)) {
            $do_gen=1;
            last;
          };
        };
      };
    };


    # run the generator script
    if($do_gen) {
      my $rel=$gen;
      relto_root($rel);
      Log->ex($rel);
      `$gen`;

      $done=1;
    };

  };

  Log->line() if $done;
  return;
};


# ---   *   ---   *   ---
# plain cp

sub update_regular($self) {
  my @FCPY=map {
    (Shb7::Bfile->is_valid($ARG))
      ? $ARG->unroll('src','out')
      : $ARG
      ;

  } @{$self->{fcpy}};

  my $done=0;

  Log->step("copying regular files")
  if @FCPY;

  while(@FCPY) {
    my $og=shift @FCPY;
    my $cp=shift @FCPY;

    my @ar=split '/',$cp;
    my $base_path=join '/',@ar[0..$#ar-1];

    reqdir $base_path;


    my $do_cpy=! -e $cp;

    $do_cpy=(! $do_cpy)
      ? ot($cp,$og) || $self->{clean}
      : $do_cpy
      ;

    if($do_cpy) {
      Log->substep($og);
      `cp $og $cp`;

      $done=1;
    };

  };

  Log->line() if $done;
  return;
};


# ---   *   ---   *   ---
# re-run object file compilation

sub update_objects($self) {
  my $bfiles = [];
  my $objblt = 0;

  my @files  = $self->get_build_files();

  Log->step("rebuilding objects")
  if @files;

  # iter list of source files
  for my $bfile(@files) {
    $objblt+=$bfile->update($self->{bld});

    push @$bfiles,$bfile
    if $bfile->linkable();

  };

  $self->{bld}->push_files(@$bfiles);
  Log->line() if $objblt;

  return $objblt;
};


# ---   *   ---   *   ---
# picks backend from source ext

sub bk_for($self,$src) {
  my $out=undef;

  if($src=~ Ftype::Text::C->{ext}) {
    $out=$self->{gcc};

  } elsif($src=~ Ftype::Text::Perl->{ext}) {
    $out=$self->{mam};
  };

  return $out;
};


# ---   *   ---   *   ---
# manages utils and tests

sub side_builds($self) {
  my @calls  = ();
  my $done   = 0;

  my $bindir = $self->{root}.'bin/';
  my $srcdir = $self->{root}.$self->{fswat}.q[/];

  for my $ref(@{$self->{util}}) {
    my ($outfile,$srcfile,@flags)=@$ref;
    my $bld=Shb7::Build->new(
      file => [],
      name => $bindir.$outfile,

      inc  => $self->{inc},
      lib  => [
        q[-l].$self->{mkwat},
        @{$self->{lib}},

      ],

      shared  => 0,
      debug   => $self->{debug},

      tgt     => Shb7::Bk->TARGET->{x64},
      linking => 'cstd',
    );

    my $bk    = $self->bk_for($srcfile);
    my $bfile = $bk->push_src($srcdir.$srcfile);

    $done|=$bfile->update($bld);

    $bld->push_files($bfile);
    $bld->push_flags(@flags);

    $bld->olink() if $bfile->linkable();

  };

  Log->line() if $done;
  return;
};


# ---   *   ---   *   ---
# the one we've been waiting for
#
# this sub only builds a new binary IF
# there is a target defined AND
# any objects have been updated

sub build_binaries($self,$objblt) {
  my @calls = ();
  my @libs  = ();

  my @objs  = map {
    $ARG->{obj}

  } @{$self->{bld}->{file}};

  @libs=@{$self->{bld}->{lib}};

  if($self->{main}
  && (($objblt || $self->{clean}) && @objs)) {
    my $rel=$self->{main};
    relto_root($rel);
    Log->fupdate($rel,'compiling binary');


    # build mode is 'static library'
    if($self->{lmode} eq 'ar') {
      push @calls,[
        qw(ar -crs),
        $self->{main},@objs
      ];

    # otherwise it's executable or shared object
    } else {
      if(-f $self->{main}) {
        unlink $self->{main};
      };

      # for executables we spawn a shadow lib
      if($self->{lmode} ne '-shared ') {
        push @calls,[
          qw(ar -crs),
          $self->{mlib},@objs
        ];
      };

      $self->{bld}->olink();
    };

  };


  # run build calls and make symbol tables
  for my $call(@calls) {
    filter($call);
    system {$call->[0]} @$call;
  };

  if(@libs && $self->{ilib}) {
    Log->fupdate(
      $self->{fswat},
      'compiling shwl for'
    );

    Avt::Xcav::symscan(
      $self->{fswat},
      $self->{ilib},

      \@libs,

      @{$self->{xprt}}
    );
  };

  return;
};


# ---   *   ---   *   ---
# writes *.pm dependency files

sub depsmake($self) {
  my $md    = $Shb7::Build::Makedeps;

  my @objs  = @{$md->{obj}};
  my @deps  = @{$md->{dep}};

  my $fswat = $self->{fswat};

  Log->step('rebuilding dependencies')
  if @objs && @deps;

  my $ex=Shb7::Bfile->avtopath() . q[/bin/pmd];

  while(@objs && @deps) {
    my $obj=shift @objs;
    my $dep=shift @deps;

    next if $obj=~ m[Depsmake\.pm$];

    my $body=`$ex $fswat $obj`;
    owc($dep,$body);
  };

  Shb7::Build::clear_makedeps();
  return;
};


# ---   *   ---   *   ---
1; # ret
