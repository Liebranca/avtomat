#!/usr/bin/perl
# ---   *   ---   *   ---
# MAKESCRIPT
# Builds your shit
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package Avt::Makescript;
  use v5.42.0;
  use strict;
  use warnings;

  use English qw($ARG);
  use Storable qw(retrieve);
  use Cwd qw(abs_path getcwd);

  use lib "$ENV{ARPATH}/lib/sys/";
  use Style qw(null);
  use Chk qw(is_null);
  use Cli;
  use Log;

  use Arstd::String qw(catpath);
  use Arstd::Array qw(filter dupop);
  use Arstd::Path qw(
    dirof
    parof
    reqdir
    absto
    relto
  );
  use Arstd::Bin qw(ot moo orc owc);

  use Shb7::Path qw(
    root
    set_root
    relto_root
    dirp
    trashp
    include
  );
  use Shb7::Find qw(ffind wfind);

  use Shb7::Bfile;
  use Shb7::Build;
  use Shb7::Link qw(olink);
  use Shb7::Bk::cmam;
  use Shb7::Bk::mam;
  use Shb7::Bk::flat;
  use Shb7::Bk::fake;

  use Tree::Dep;

  use Ftype::Text::C;
  use Ftype::Text::Perl;

  use lib "$ENV{ARPATH}/lib/";
  use AR;
  use Emit::Std;
  use Avt::XS;


# ---   *   ---   *   ---
# info

  our $VERSION = 'v0.01.8';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# ROM

my $PKG=__PACKAGE__;


# ---   *   ---   *   ---
# get bfiles of all containers

sub get_build_files($self) {
  return (
    $self->fasm_bfiles(),
    $self->{cmam}->bfiles(),
    $self->{mam}->bfiles(),
  );
};


# ---   *   ---   *   ---
# [DEPRECATED] get sorted bfile list
#
# NOTE:
#
# fasm headers (with the old AR/forge
# system) can't be included out of order
# as they are generated by the build itself!
#
# due to this, we have to sort this
# flist accto the dependency list

sub fasm_bfiles($self) {
  return () if ! int $self->{flat}->bfiles();
  AR::load('Avt::flatten');

  my @src   = $self->{flat}->bfiles();
  my %keys  = map {
    abs_path($ARG->{src})=>$ARG

  } @src;

  # ^get sorted deps that are
  # part of this compilation
  my @flatk = map {
    $ARG;

  } grep {
    exists $keys{$ARG}

  } Avt::flatten->cpproc(
    'build_deps',
    @src
  );

  # ^remove duplicates
  dupop(\@flatk);
  my @flat=map {$keys{$ARG}} @flatk;

  map {delete $keys{$ARG}} @flatk;

  # ^add remaining files
  my @rem=grep {
    exists $keys{abs_path($ARG->{src})}

  } @src;

  return (@flat,@rem);
};


# ---   *   ---   *   ---
# adjust fpath arrays

sub make_abspaths {
  for my $ar(
    $_[0]->{xprt},
    $_[0]->{gen},
    $_[0]->{inc},
    $_[0]->{lib}
  ) {
    filter $ar;
    for my $path(@$ar) {
      # remove -[char] prefix
      my $prefix_re   =  qr{^(-[ILl])};
         $path        =~ s[$prefix_re][];

      my $prefix      =  $1;
         $prefix    //=  null;

      # ^ make absolute path, and
      #   *then* put prefix back in
      absto($path,$_[0]->{root});
      $path="$prefix$path";
    };
  };

  for(qw(ilib mlib main trash)) {
    absto($_[0]->{$ARG},$_[0]->{root});
  };

  filter $_[0]->{fcpy};
  for my $bfile(
    @{$_[0]->{fcpy}},
    $_[0]->get_build_files(),
  ) {
    $bfile->ensure_outdirs();
    for(qw(src obj asm out dep)) {
      absto($bfile->{$ARG},$_[0]->{root});
    };
  };

  return;
};


# ---   *   ---   *   ---
# cstruc

sub new($class) {
  my $self=bless {
    # name of target
    fswat => null,
    mkwat => null,

    # build file containers
    flat  => Shb7::Bk::flat->new(
      pproc=>'Avt::flatten::pproc',
    ),

    cmam  => Shb7::Bk::cmam->new(),
    mam   => Shb7::Bk::mam->new(),

    # io paths
    root  => null,
    ilib  => null,
    mlib  => null,
    main  => null,
    trash => null,

    # fpath arrays
    xprt  => [],
    fcpy  => Shb7::Bk::fake->new(),
    gen   => [],
    util  => [],
    test  => [],

    # search paths/deps
    inc  => [],
    lib  => [],

    # flags
    lmode => null,
    debug => 0,
    clean => 0,

  },$class;

  return $self;
};


# ---   *   ---   *   ---
# entry point

sub build_module($class,$file,@cmd) {
  my $dir  = dirof $file;
  my $root = parof $file;

  set_root($root);
  chdir $root;

  my $self=$class->load("$dir/.avto-cache",@cmd);
  $self->run(@cmd);

  return $self;
};


# ---   *   ---   *   ---
# makefile body

sub run($self) {
  $self->update_generated;
  $self->build_binaries($self->update_objects);
  $self->update_regular;
  $self->side_builds;

  return;
};


# ---   *   ---   *   ---
# get make config from file

sub load($class,$file,@cmd) {
  my $self=retrieve $file;
  my ($cli,@args)=$class->read_cli(@cmd);

  $self->{debug} = $cli->{debug} ne null;
  $self->{clean} = $cli->{clean} ne null;

  $self->{root}  = root();
  $self->{trash} = trashp($self->{fswat});

  Shb7::Path::module($self->{fswat});
  $self->make_abspaths();
  $self->set_build_paths();

  $self->{bld}=Shb7::Build->new(
    file    => [],
    name    => $self->{main},

    inc     => $self->{inc},
    lib     => $self->{lib},

    shared  => $self->{lmode} eq '-shared',
    debug   => $self->{debug},
    clean   => $self->{clean},
    def     => $cli->{def},

    tgt     => Shb7::Bk::target_arch('x64'),

    linking => ($cli->{flat} ne null)
      ? 'flat'
      : 'cstd'
      ,
  );

  return $self;
};


# ---   *   ---   *   ---
# ^iface

sub read_cli($class,@cmd) {
  state @tab=(
    { id    => 'clean',
      short => '-c',
      long  => '--clean',
      argc  => 0

    },{
      id    => 'debug',
      short => '-g',
      long  => '--debug',
      argc  => 0

    },{
      id    => 'clean-debug',
      short => '-gc',
      long  => '--clean-debug',
      argc  => 0

    },{
      id      => 'def',
      short   => '-D',
      long    => '--define',
      argc    => 'array',
      default => [],

    },{
      id    => 'flat',
      short => '-f',
      long  => '--flat',
      argc  => 0
    },
  );


  # ^make ice and run
  my $cli  = Cli->new(@tab);
  my @args = $cli->take(@cmd);

  if($cli->{'clean-debug'} ne null) {
    $cli->{debug}=1;
    $cli->{clean}=1;
    delete $cli->{'clean-debug'};
  };

  # ^give
  return ($cli,@args);
};


# ---   *   ---   *   ---
# add makescript includes to
# current search path

sub set_build_paths($self) {
  my @paths=grep {
    $ARG ne "-I$self->{root}";

  } @{$self->{inc}};

  push @paths,(dirp($self->{fswat}),'.');

  include(@paths);
  return;
};


# ---   *   ---   *   ---
# handle code generator scripts

sub update_generated($self) {
  my @GENS = @{$self->{gen}};
  my $done = 0;

  Log->step("running generators")
  if @GENS;

  # iter the list of generator scripts
  # ... and sources/dependencies for them
  for my $ref(@GENS) {
    my ($res,$gen,@msrcs)=@$ref;

    # make sure we don't need to update
    my $do_gen=(-e $res)
      ? ot($res,$gen) || $self->{clean}
      : 1
      ;

    # make damn sure we don't need to update
    if(! $do_gen) {
      while(@msrcs) {
        my $msrc=shift @msrcs;

        # look for wildcard
        if($msrc=~ Shb7::Find::wildcard_re()) {
          for my $src(wfind($msrc)) {
            # found file is updated
            if(Shb7::ot($res,$src)) {
              $do_gen=1;
              last;
            };
          };

          last if $do_gen;


        # look for specific file
        } else {
          $msrc=ffind($msrc);
          next if !$msrc;

          # found file is updated
          if(ot($res,$msrc)) {
            $do_gen=1;
            last;
          };
        };
      };
    };


    # run the generator script
    if($do_gen) {
      my $rel=$gen;
      relto_root($rel);
      Log->ex($rel);
      `$gen`;

      $done=1;
    };

  };

  Log->line() if $done;
  return;
};


# ---   *   ---   *   ---
# plain cp

sub update_regular($self) {
  my @FCPY=map {
    (Shb7::Bfile->is_valid($ARG))
      ? $ARG->unroll('src','out')
      : $ARG
      ;

  } @{$self->{fcpy}};

  my $done=0;

  Log->step("copying regular files")
  if @FCPY;

  while(@FCPY) {
    my $og=shift @FCPY;
    my $cp=shift @FCPY;

    my @ar=split '/',$cp;
    my $base_path=join '/',@ar[0..$#ar-1];

    reqdir $base_path;


    my $do_cpy=! -e $cp;

    $do_cpy=(! $do_cpy)
      ? ot($cp,$og) || $self->{clean}
      : $do_cpy
      ;

    if($do_cpy) {
      Log->substep($og);
      `cp $og $cp`;

      $done=1;
    };

  };

  Log->line() if $done;
  return;
};


# ---   *   ---   *   ---
# re-run object file compilation

sub update_objects($self) {
  my $bfiles=[];
  my $objblt=0;

  # skip if nothing to build
  return $objblt if ! $self->get_build_files();

  Log->step("rebuilding objects");


  # iter backends
  # each holds it's own list of source files
  for(qw(flat cmam mam)) {
    my ($cnt,@link)=
      $self->{$ARG}->build($self->{bld});

    $objblt+=$cnt;
    push @$bfiles,@link;
  };

  # save linkable files
  $self->{bld}->push_files(@$bfiles);
  Log->line() if $objblt;

  return $objblt;
};


# ---   *   ---   *   ---
# picks backend from source ext

sub bk_for($self,$src) {
  my $out=undef;

  if($src=~ Ftype::Text::C->{ext}) {
    $out=$self->{cmam};

  } elsif($src=~ Ftype::Text::Perl->{ext}) {
    $out=$self->{mam};
  };

  return $out;
};


# ---   *   ---   *   ---
# manages utils and tests

sub side_builds($self) {
  my @calls  = ();
  my $done   = 0;

  my $bindir = $self->{root}.'bin/';
  my $srcdir = $self->{root}.$self->{fswat}.q[/];

  for my $ref(@{$self->{util}}) {
    my ($outfile,$srcfile,@flags)=@$ref;
    my $bld=Shb7::Build->new(
      file => [],
      name => $bindir.$outfile,

      inc  => $self->{inc},
      lib  => [
        q[-l].$self->{mkwat},
        @{$self->{lib}},

      ],

      shared  => 0,
      debug   => $self->{debug},

      tgt     => Shb7::Bk->TARGET->{x64},
      linking => 'cstd',
    );

    my $bk    = $self->bk_for($srcfile);
    my $bfile = $bk->push_src($srcdir.$srcfile);

    $done|=$bfile->update($bld);

    $bld->push_files($bfile);
    $bld->push_flags(@flags);

    olink($bld) if $bfile->linkable();

  };

  Log->line() if $done;
  return;
};


# ---   *   ---   *   ---
# the one we've been waiting for
#
# this sub only builds a new binary IF
# there is a target defined AND
# any objects have been updated

sub build_binaries($self,$objblt) {
  my @calls = ();
  my @libs  = ();

  my @objs  = map {
    $ARG->{obj}

  } @{$self->{bld}->{file}};

  @libs=@{$self->{bld}->{lib}};

  if($self->{main}
  && (($objblt || $self->{clean}) && @objs)) {
    my $rel=$self->{main};
    relto_root($rel);
    Log->fupdate($rel,'compiling binary');


    # build mode is 'static library'
    if($self->{lmode} eq 'ar') {
      push @calls,[
        qw(ar -crs),
        $self->{main},@objs
      ];

    # otherwise it's executable or shared object
    } else {
      if(-f $self->{main}) {
        unlink $self->{main};
      };

      # for executables we spawn a shadow lib
      if($self->{lmode} ne '-shared ') {
        push @calls,[
          qw(ar -crs),
          $self->{mlib},@objs
        ];
      };

      olink($self->{bld});
    };

  };


  # run build calls and make symbol tables
  for my $call(@calls) {
    filter($call);
    system {$call->[0]} @$call;
  };

  my @xprt=();
  for my $bfile($self->{cmam}->bfiles()) {
    push @xprt,
    grep {$bfile->{src} eq $ARG}

    @{$self->{xprt}};
  };

  if(@libs && $self->{ilib} && @xprt) {
    Log->fupdate(
      $self->{mkwat},
      'compiling shwl for'
    );

    my $shwl=Avt::XS::mkshwl(
      $self->{fswat},
      $self->{ilib},
      \@libs,
      @xprt
    );
    Avt::XS::build(
      $shwl,
      $self->{bld},
      $self->{mkwat},
      -f=>1,
    );
    Avt::XS::load($self->{mkwat});
  };

  return;
};


# ---   *   ---   *   ---
# writes *.pmd dependency files for MAM

sub depsmake($self) {
  # Shb7::Bk::mam populates this hash for us
  my $md  = Shb7::Build::makedeps();
  my $src = $md->{obj};
  my $dst = $md->{dep};

  return if ! @$src ||! @$dst;

  # notify we're here
  Log->step('rebuilding dependencies');

  # run through the files...
  for my $i(0..@$src-1) {
    my $rel=$src->[$i];
    relto($rel);
    Log->substep($rel);

    # we *execute* the file in a "sandbox"
    # to get the dependency list (!!!)
    #
    # its the same process as a syntax check
    # (like `perl -c`), but it doesn't require
    # forking, so its incredibly faster
    my @dep=AR::reload(
      'Chk::Deps',
      $src->[$i],
      orc($src->[$i])
    );

    # drop first elem as its just the
    # name of the file itself
    shift @dep;

    # save the dependency list to a *.pmd file
    my $body=join "\n",@dep;
    owc($dst->[$i],$body);
  };

  # cleanup and give
  Shb7::Build::clear_makedeps();
  return;
};


# ---   *   ---   *   ---
1; # ret
