#!/usr/bin/perl
# ---   *   ---   *   ---
# SYGEN
# Makes syntax files from
# Ftype::Text instances
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package sygen;
  use v5.42.0;
  use strict;
  use warnings;

  use English qw($ARG);

  use lib "$ENV{ARPATH}/lib/";
  use AR;

  use lib "$ENV{ARPATH}/lib/sys/";
  use Style qw(null);
  use Chk qw(
    is_arrayref
    is_hashref
    is_qre
  );
  use Arstd::Bin qw(xdorc);
  use Arstd::Path qw(extcl relto to_pkg);
  use Arstd::Array;
  use Arstd::String qw(cat gstrip dqwrap sqwrap);
  use Arstd::Re;
  use Arstd::throw;

  use Ftype;
  use parent 'St';


# ---   *   ---   *   ---
# info

  our $VERSION = 'v0.02.1';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# ROM

my $PKG=__PACKAGE__;
St::vconst {

  COLORS=>[qw(
    black red green yellow
    blue magenta cyan white

    brightblack

    brightred brightgreen

    brightyellow brightblue

    brightmagenta brightcyan

    brightwhite

  )],


  # ordered list of attrs to use for highlighting
  KEYCOLOR_LIST => [
    line        => 0x07,
    nblank      => 0x07,
    drfc        => 0x04,

    uc_name     => 0x0D,
    fn          => 0x01,
    shcmd       => 0x01,

    builtin     => 0x01,
    fctl        => 0x0D,
    type        => 0x04,
    specifier   => 0x04,

    intrinsic   => 0x04,
    directive   => 0x0D,
    resname     => 0x04,

    pesc        => 0x0E,
    preproc     => 0x0E,

    num         => 0x03,
    opr         => 0x0F,
    char        => 0x0E,
    string      => 0x0E,

    highlight   => 0x00,

    lcom        => 0x02,
    dev0        => 0x0B,
    dev1        => 0x09,

    blank       => 0x66,

  ],

  # ^hash-ify for convenience
  KEYCOLOR_HASH => sub {
    my $color=$_[0]->KEYCOLOR_LIST;
    return {@$color};

  },

};


# ---   *   ---   *   ---
# point to avtomat and retrieve langdefs

sub get_files {
  return xdorc(
    './avtomat/sys/Ftype/Text/',
    -r=>1,

  );

};


# ---   *   ---   *   ---
# ^import
#
# [0]: byte ptr ; filename

sub load_file {

  # shorten and clear extension
  my $re=qr{^avtomat/*sys/*};
  extcl relto $_[0],$ENV{ARPATH};
  $_[0]=~ s[$re][];

  # ^turn into package and load it
  my $class="Ftype/Text/$_[0]";
  to_pkg $class;

  AR::cloadi $class;

  # give ice
  return Ftype->fet($class);

};


# ---   *   ---   *   ---
# plain xlate

sub get_color_name { return join ',',(
  $PKG->COLORS->[$_[0]  & 0xF],
  $PKG->COLORS->[$_[0] >> 0x4],

)};


# ---   *   ---   *   ---
# processes langdef attributes to use
# in a posix regex

sub prprops($def,$key) {

  # extract from instance?
  if($key eq 'highlight') {
    my $have=$def->{highlight};
    return map {
      my $value=$have->[$ARG*2+0];
      my $color=$have->[$ARG*2+1];
      make_rule($def,$key,$value,$color)

    } 0..int(@$have/2)-1;

  };


  # ^nope, use inner table
  my ($value,$color)=(
    $def->fet($key),
    $PKG->KEYCOLOR_HASH->{$key},

  );

  return make_rule($def,$key,$value,$color);

};


# ---   *   ---   *   ---
# extract patterns from value

sub extract($def,$key,$value) {

  # scalar as-is
  return $value
  if ! length ref $value
  || is_qre $value;

  # ^arrayref as list
  return @$value
  if is_arrayref $value;

  # ^throw if not a hashref
  throw(
    "Invalid value type: "
  . sqwrap(ref $value)

  ) if ! is_hashref $value;


  # ^hashref is... complicated ;>
  delete $value->{-re};

  my @keys = keys %$value;
  my @out  = ();


  # this abomination exists to accomodate sigils
  if(exists $def->{use_sigils}->{$key}) {
    my @exclude = ();
    my @noproc  = ();

    map {
      if(! ($ARG=~ m[ ^\(+ (\[\$ | \\\$) ]x)) {
        push @exclude,$ARG;

      } else {
        push @noproc,$ARG;

      };

    } @keys;

    @out  = @noproc;
    @keys = @exclude;

  };


  # output key lists in blocks
  # for some reason this is faster
  for(my $x=0;$x < @keys;$x+=32) {
    my $top=(@keys > $x+31)
      ? $x+31
      : $#keys
      ;

    my @slice=sort {
      (length $a) <= (length $b);

    } map {
      Arstd::Re::qre2re($ARG);
      $ARG;

    } (@keys[$x..$top]);


    # join them into a single expression
    push @out,($key eq 'num')
      ? '('   . (join '|',@slice) . ')'
      : '\b(' . (join '|',@slice) . ')\b'
      ;

  };


  return @out;

};


# ---   *   ---   *   ---
# output patterns for specific entry

sub make_rule($def,$key,$value,$color) {

  return () if ! defined $value;
  $color=get_color_name $color;

  map {
    $ARG=~ s[\s+|\n][]sxmg;
    $ARG=  cat gstrip split "\n",$ARG;

    Arstd::Re::qre2re($ARG);
    $ARG=dqwrap $ARG;

    "color $color $ARG";

  } extract($def,$key,$value);

};


# ---   *   ---   *   ---
# ^goes through all rules

sub get_file_syntax {
  return join "\n",map {
    prprops($_[0],$ARG);

  } ((Arstd::Array::nkeys $PKG->KEYCOLOR_LIST));

};


# ---   *   ---   *   ---
# iters through langdefs
# outs a nanorc file for each

sub make_syntax_files(%O) {

  # open dst file
  my ($def,$fpath)=($O{def},$O{fpath});
  open my $fh,'>',$fpath or throw $fpath;

  # nano syntax file boiler
  my $prop='syntax '.(
    $def->{name} .' "'.
    $def->{ext} . '"'

  )."\n";

  $prop .= 'header ' . dqwrap($def->{hed}) . "\n";
  $prop .= 'magic ' . dqwrap($def->{mag}) . "\n";


  # de-escape comments
  my $com=$def->{com};
  $com=~ s[\\][]sg;

  $prop .= 'comment ' . dqwrap($com) . "\n";


  # get base patterns list and
  # spit the whole thing out
  print {$fh} $prop . get_file_syntax $def;


  # cleanup and give
  close $fh or throw $fpath;
  return;

};


# ---   *   ---   *   ---
# entry point

sub generate {
  chdir $ENV{ARPATH}
  or throw "Error cd'ing into ARPATH";

  my $config  = glob("~/.config");
  my $nanorc  = "$config/nano";

  `mkdir -p $nanorc` if ! -d $nanorc;


  # run the generator
  map {
    my $def=load_file $ARG;
    make_syntax_files(
      def   => $def,
      fpath => "$nanorc/$def->{name}.nanorc",

    );

  } get_files;

};

generate;


# ---   *   ---   *   ---
1; # ret
