#!/usr/bin/perl
# ---   *   ---   *   ---
# SYGEN
# Creates syntax files from
# available definitions
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use v5.36.0;
  use strict;
  use warnings;

  use English qw(-no_match_vars);

  use lib $ENV{'ARPATH'}.'/lib/sys/';

  use Style;
  use Arstd::String;
  use Arstd::Array;
  use Chk;

  use Shb7;

  use lib $ENV{'ARPATH'}.'/lib/';

  use Lang;

# ---   *   ---   *   ---
# ROM

  my @COLORS=qw(

    black red green yellow
    blue magenta cyan white

    grey

    brightred brightgreen

    brightyellow brightblue

    brightmagenta brightcyan

    brightwhite

  );

# ---   *   ---   *   ---
# ordered list of attrs to use for highlighting

  my @KEYCOLOR=(

    common=>0x07,
    hier=>0x04,
    names_u=>0x0D,
    pfun=>0x01,
    shcmds=>0x01,
    pesc=>0x0E,

    builtins=>0x01,
    fctls=>0x0D,
    types=>0x04,
    specifiers=>0x04,

    intrinsics=>0x04,
    directives=>0x0D,
    resnames=>0x04,

    nums=>0x03,
    vstr=>0x03,
    ops=>0x0F,
    chars=>0x0E,
    strings=>0x0E,
    preproc=>0x0E,

    lcom=>0x02,
    dev0=>0x0B,
    dev1=>0x09,
    dev2=>0x66,

  );

  # ^hash-ify for convenience
  my %KEYCOLOR=@KEYCOLOR;

# ---   *   ---   *   ---
# remarkable exceptions to the rule

  my $EITHS_NOWB={

    'Perl'=>{types=>1,},
    'Raku'=>{types=>1,},

  };

# ---   *   ---   *   ---
# global state

  my $FH=undef; # one is enough

# ---   *   ---   *   ---
# point to avtomat and retrieve langdefs

Shb7::set_root($ENV{'ARPATH'});
my $Tree=Shb7::walk('avtomat/Lang');

# these files do not output a syntax file
my $EXCLUDED=qr{

  (?: Def[.]pm$)

}x;

# ^get list of files that do
my @Files=grep
  {!($ARG=~ $EXCLUDED)}
  $Tree->get_file_list()

;

# ^import from list
for my $lang(@Files) {

  $lang=Shb7::shpath($lang);
  $lang=~ s[^avtomat/Lang/][];
  $lang=~ s/[.]pm$//;

  # load the package
  eval(q{use Lang::}.$lang.';');

  # ^get reference to instance
  $lang=eval(q{Lang->}.$lang);

};

# ---   *   ---   *   ---
# processes langdef attributes to use
# in a posix regex

sub prprops($def,$key) {

  my $color;
  my $v;

  if($key eq 'highlight') {
    $v=shift @{$def->{highlight}};
    $color=shift @{$def->{highlight}};

  } else {
    $v=$def->{$key};
    $color=$KEYCOLOR{$key};

  };

  # decode color
  { my ($fg,$bg)=($color&0xF,$color>>4);
    $color=$COLORS[$fg].','.$COLORS[$bg];

  };

  # nano syntax re was written by a degenerate
  # [\[\]] does not match square brackets

  if($key eq 'ops') {
    $v='([^\s_A-Za-z0-9]|\\\\)';

  };

  # ^he's a double degenerate, the standard
  # string matching patterns are terrible

  if($key=~ m/(?:

    strings|chars|shcmds|preproc|pesc

  )/x) {

    if($key eq 'strings') {
      $v=Lang::delim(q{"});

    } elsif($key eq 'chars') {
      $v=Lang::delim(q{'});

    } elsif($key eq 'shcmds') {
      $v=Lang::delim(q{`});

    } elsif($key eq 'preproc') {
      $v='^\s*#.*$';

    } else {
      $v='\$\:.*;>';

    };

  };

# ---   *   ---   *   ---
# extract patterns

  my @ar=($v);

  if(is_arrayref($v)) {
    @ar=@{$v};

  } elsif(is_hashref($v)) {

    delete $v->{re};

    my @keys=keys %{$v};
    @ar=();

# ---   *   ---   *   ---
# this abomination exists to accomodate sigils

    if(exists $EITHS_NOWB
      ->{$def->{name}}
      ->{$key}

    ) {

      my @exclude=();
      my @noproc=();

      for my $elem(@keys) {
        if(!($elem=~ m/^\(+(\[\$|\\\$)/)) {
          push @exclude,$elem;

        } else {
          push @noproc,$elem;

        };

      };

      @ar=@noproc;
      @keys=@exclude;

    };

# ---   *   ---   *   ---
# output key lists in blocks
# for some reason this is faster

    for(my $x=0;$x<@keys;$x+=32) {

      my $top=(@keys>$x+31)
        ? $x+31 : $#keys;

      my @slice=(@keys[$x..$top]);
      for my $re(@slice) {
        if(is_qre($re)) {
          Lang::qre2re(\$re);

        };

      };


      # sort keys by length
      @slice=sort {
        (length $a)<=(length $b);

      } @slice;

      # join them into a single expression
      my $re;
      if($key eq 'nums') {
        $re='('.(join '|',@slice).')';

      } else {
        $re='\b('.(join '|',@slice).')\b';

      };

      push @ar,$re;


    };

  };

# ---   *   ---   *   ---
# output patterns

  for my $re(@ar) {

    $re=~ s/\s+|\n//sxmg;
    $re=join '\n',(split "\n",$re);

    if(is_qre($re)) {
      Lang::qre2re(\$re);

    };

    $re=dqwrap($re);
    print {$FH} "color $color $re\n";

  };

};

# ---   *   ---   *   ---
# iters through langdefs
# outs a nanorc file for each

sub make_syntax_files(@args) {
while(@args) {

  my $def=shift @args;
  my $dst=shift @args;

  open $FH,'>',$dst or die strerr($dst);

  # nano syntax file boiler
  my $prop='syntax '.(

    $def->{name}.' "'.
    $def->{ext}.'"'

  )."\n";

  $prop.='header '.dqwrap($def->{hed})."\n";
  $prop.='magic '.dqwrap($def->{mag})."\n";

  # de-escape comments
  $def->{com}=~ s/\\//sg;

  my $com=$def->{com};
  $def->{lcom}=~ s/\\${com}/$com/sg;

  $prop.='comment '.dqwrap($def->{com})."\n";

  # spit it out
  print {$FH} "$prop\n";

  # get patterns list
  for my $key(array_keys(\@KEYCOLOR)) {
    prprops($def,$key);

  };

  # overwrite rules
  while(@{$def->{highlight}}) {
    prprops($def,'highlight');

  };

  close $FH or die strerr($dst);

}};

# ---   *   ---   *   ---
# run the generator

my @LangData=();
my $Path=glob("~/.config/nano");

for my $lang(@Files) {

  push @LangData,

    # Lang::Def instance
    $lang,

    # destination file
    "$Path/$lang->{name}.nanorc"

  ;

};

make_syntax_files(@LangData);

# ---   *   ---   *   ---
1; # ret
