#!/usr/bin/perl
# ---   *   ---   *   ---
# SYGEN
# Creates syntax files from
# available definitions
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use v5.36.0;
  use strict;
  use warnings;

  use English qw(-no_match_vars);

  use lib $ENV{'ARPATH'}.'/lib/sys/';

  use Style;
  use Arstd::String;
  use Arstd::Array;
  use Chk;

  use Shb7;

  use lib $ENV{'ARPATH'}.'/lib/';

  use Lang;

# ---   *   ---   *   ---
# ROM

  my @COLORS=qw(

    black red green yellow
    blue magenta cyan white

    grey

    brightred brightgreen

    brightyellow brightblue

    brightmagenta brightcyan

    brightwhite

  );

# ---   *   ---   *   ---
# ordered list of attrs to use for highlighting

  my @KEYCOLOR=(

    common      => [0x07,'non'],

    hier        => [0x04,'identifier.ns'],
    names_u     => [0x0D,'constant'],
    pfun        => [0x01,'identifier.fn'],
    shcmds      => [0x01,'constant.shcmd'],
    pesc        => [0x0E,'preproc.peso'],

    builtins    => [0x01,'identifier.bltn'],
    fctls       => [0x0D,'statement'],
    types       => [0x04,'type'],
    specifiers  => [0x04,'type.spec'],

    intrinsics  => [0x04,'special'],
    directives  => [0x0D,'identifier.dir'],
    resnames    => [0x04,'identifier.res'],

    nums        => [0x03,'constant.number'],
    vstr        => [0x03,'constant.vstr'],
    ops         => [0x0F,'symbol.operator'],
    chars       => [0x0E,'constant.char'],
    strings     => [0x0E,'constant.string'],
    preproc     => [0x0E,'preproc'],

    lcom        => [0x02,'comment'],
    dev0        => [0x0B,'todo'],
    dev1        => [0x09,'error'],
    dev2        => [0x66,'special.blank'],

  );

  # ^hash-ify for convenience
  my %KEYCOLOR=@KEYCOLOR;

# ---   *   ---   *   ---
# remarkable exceptions to the rule

  my $EITHS_NOWB={

    'Perl'=>{types=>1,},
    'Raku'=>{types=>1,},

  };

# ---   *   ---   *   ---
# global state

  my $FNANO  = undef;
  my $FMICRO = undef;

# ---   *   ---   *   ---
# point to avtomat and retrieve langdefs

Shb7::set_root($ENV{'ARPATH'});
my $Tree=Shb7::walk('avtomat/Lang');

# these files do not output a syntax file
my $EXCLUDED=qr{

  (?: Def[.]pm$)

}x;

# ^get list of files that do
my @Files=grep
  {!($ARG=~ $EXCLUDED)}
  $Tree->get_file_list()

;

# ^import from list
for my $lang(@Files) {

  $lang=Shb7::shpath($lang);
  $lang=~ s[^avtomat/Lang/][];
  $lang=~ s/[.]pm$//;

  # load the package
  eval(q{use Lang::}.$lang.';');

  # ^get reference to instance
  $lang=eval(q{Lang->}.$lang);

};

# ---   *   ---   *   ---
# processes langdef attributes to use
# in a posix regex

sub prprops($def,$key) {

  my ($color,$mname,$v);

  if($key eq 'highlight') {
    $v=shift @{$def->{highlight}};
    $color=shift @{$def->{highlight}};

  } else {
    $v=$def->{$key};
    ($color,$mname)=@{$KEYCOLOR{$key}};

  };

  # decode color
  { my ($fg,$bg)=($color&0xF,$color>>4);
    $color=$COLORS[$fg].','.$COLORS[$bg];

  };

  # nano syntax re was written by a degenerate
  # [\[\]] does not match square brackets

  if($key eq 'ops') {
    $v='([^\s_A-Za-z0-9]|\\\\)';

  };

  # ^he's a double degenerate, the standard
  # string matching patterns are terrible

  if($key=~ m/(?:

    strings|chars|shcmds|preproc|pesc

  )/x) {

    if($key eq 'strings') {
      $v=Lang::delim(q{"});

    } elsif($key eq 'chars') {
      $v=Lang::delim(q{'});

    } elsif($key eq 'shcmds') {
      $v=Lang::delim(q{`});

    } elsif($key eq 'preproc') {
      $v='^\s*#.*$';

    } else {
      $v='\$\:.*;>';

    };

  };

# ---   *   ---   *   ---
# extract patterns

  my @ar=($v);

  if(is_arrayref($v)) {
    @ar=@{$v};

  } elsif(is_hashref($v)) {

    delete $v->{re};

    my @keys=keys %{$v};
    @ar=();

# ---   *   ---   *   ---
# this abomination exists to accomodate sigils

    if(exists $EITHS_NOWB
      ->{$def->{name}}
      ->{$key}

    ) {

      my @exclude=();
      my @noproc=();

      for my $elem(@keys) {
        if(!($elem=~ m/^\(+(\[\$|\\\$)/)) {
          push @exclude,$elem;

        } else {
          push @noproc,$elem;

        };

      };

      @ar=@noproc;
      @keys=@exclude;

    };

# ---   *   ---   *   ---
# output key lists in blocks
# for some reason this is faster

    for(my $x=0;$x<@keys;$x+=32) {

      my $top=(@keys>$x+31)
        ? $x+31 : $#keys;

      my @slice=(@keys[$x..$top]);
      for my $re(@slice) {
        if(is_qre($re)) {
          Lang::qre2re(\$re);

        };

      };


      # sort keys by length
      @slice=sort {
        (length $a)<=(length $b);

      } @slice;

      # join them into a single expression
      my $re;
      if($key eq 'nums') {
        $re='('.(join '|',@slice).')';

      } else {
        $re='\b('.(join '|',@slice).')\b';

      };

      push @ar,$re;


    };

  };

# ---   *   ---   *   ---
# output patterns

  for my $re(@ar) {

    $re=~ s/\s+|\n//sxmg;
    $re=join '\n',(split "\n",$re);

    if(is_qre($re)) {
      Lang::qre2re(\$re);

    };

    $re=dqwrap($re);

    print {$FNANO} "color $color $re\n";

    print {$FMICRO} "  - $mname: $re\n"
    if $mname ne 'non';

  };

};

# ---   *   ---   *   ---
# iters through langdefs
# outs a nanorc file for each

sub make_syntax_files(%O) {

  my $def        = $O{def};

  my $path_nano  = $O{fnano};
  my $path_micro = $O{fmicro};

  open $FNANO,'>',$path_nano
  or die strerr($path_nano);

  open $FMICRO,'>',$path_micro
  or die strerr($path_micro);

  # nano syntax file boiler
  my $prop='syntax '.(

    $def->{name}.' "'.
    $def->{ext}.'"'

  )."\n";

  $prop.='header '.dqwrap($def->{hed})."\n";
  $prop.='magic '.dqwrap($def->{mag})."\n";

  # de-escape comments
  $def->{com}=~ s/\\//sg;

  my $com=$def->{com};
  $def->{lcom}=~ s/\\${com}/$com/sg;

  $prop.='comment '.dqwrap($def->{com})."\n";

  # spit it out
  print {$FNANO} "$prop\n";

  # get patterns list
  for my $key(array_keys(\@KEYCOLOR)) {
    prprops($def,$key);

  };

#  # overwrite rules
#  while(@{$def->{highlight}}) {
#    prprops($def,'highlight');
#
#  };

  close $FNANO or die strerr($path_nano);
  close $FMICRO or die strerr($path_micro);

};

# ---   *   ---   *   ---
# setup paths

my $Path       = glob("~/.config");
my $Nano_Path  = "$Path/nano";
my $Micro_Path = "$Path/micro/syntax";

`mkdir -p $Nano_Path`
if ! -d $Nano_Path;

`mkdir -p $Micro_Path`
if ! -d $Micro_Path;

# ---   *   ---   *   ---
# run the generator

for my $lang(@Files) {

  make_syntax_files(

    # Lang::Def instance
    def    => $lang,

    # destination files
    fnano  => "$Nano_Path/$lang->{name}.nanorc",
    fmicro => "$Micro_Path/$lang->{name}.yaml",

  );

};

# ---   *   ---   *   ---
1; # ret
