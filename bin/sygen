#!/usr/bin/perl
# ---   *   ---   *   ---
# SYGEN
# Makes syntax files from
# Ftype::Text instances
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lib,

# ---   *   ---   *   ---
# deps

package sygen;
  use v5.42.0;
  use strict;
  use warnings;

  use English qw($ARG);

  use lib "$ENV{ARPATH}/lib/";
  use AR;

  use lib "$ENV{ARPATH}/lib/sys/";
  use Style qw(null);
  use Chk qw(
    is_arrayref
    is_hashref
    is_qre
    is_cdelim
  );
  use Arstd::Bin qw(xdorc moo);
  use Arstd::Path qw(extcl relto to_pkg reqdir);
  use Arstd::Array;
  use Arstd::String qw(cat gstrip dqwrap sqwrap);
  use Arstd::Re;
  use Arstd::throw;

  use Ftype;
  use parent 'St';


# ---   *   ---   *   ---
# info

  our $VERSION = 'v0.02.2';
  our $AUTHOR  = 'IBN-3DILA';


# ---   *   ---   *   ---
# ROM

my $PKG=__PACKAGE__;
St::vconst {
  COLORS=>[qw(
    black red green yellow
    blue magenta cyan white

    brightblack

    brightred brightgreen

    brightyellow brightblue

    brightmagenta brightcyan

    brightwhite
  )],


  # ordered list of attrs to use for highlighting
  KEYCOLOR_LIST => [
    line        => 0x07,
    nblank      => 0x07,
    highlight   => 0x00,
    drfc        => 0x04,

    uc_name     => 0x0D,
    fn          => 0x01,
    shcmd       => 0x01,

    builtin     => 0x01,
    fctl        => 0x0D,
    type        => 0x04,
    specifier   => 0x04,

    intrinsic   => 0x04,
    directive   => 0x0D,
    resname     => 0x04,

    pesc        => 0x0E,
    preproc     => 0x0E,

    num         => 0x03,
    opr         => 0x0F,
    char        => 0x0E,
    string      => 0x0E,

    highlightup => 0x00,

    lcom        => 0x02,
    dev0        => 0x0B,
    dev1        => 0x09,

    blank       => 0x66,
  ],

  # ^hash-ify for convenience
  KEYCOLOR_HASH => sub {
    my $color=$_[0]->KEYCOLOR_LIST;
    return {@$color};
  },
};


# ---   *   ---   *   ---
# point to avtomat and retrieve langdefs

sub ftype_dir {"./avtomat/sys/Ftype/Text/"};
sub get_files {
  return xdorc(ftype_dir(),-r=>1);
};


# ---   *   ---   *   ---
# ^import
#
# [0]: byte ptr ; filename

sub load_file {
  # shorten and clear extension
  my $re=qr{^avtomat/*sys/*};
  extcl relto $_[0],$ENV{ARPATH};
  $_[0]=~ s[$re][];

  # ^turn into package and load it
  my $class="Ftype/Text/$_[0]";
  to_pkg $class;
  AR::load $class => (null);

  # give ice
  return Ftype->fet($class);
};


# ---   *   ---   *   ---
# plain xlate

sub get_color_name { return join ',',(
  $PKG->COLORS->[$_[0]  & 0xF],
  $PKG->COLORS->[$_[0] >> 0x4],
)};


# ---   *   ---   *   ---
# processes langdef attributes to use
# in a posix regex

sub prprops($def,$key) {
  # extract from instance?
  if($key=~ qr{^highlight}) {
    my $have = $def->{$key};
    my @out  = ();
    my $i    = 0;

    while($i < @$have) {
      my $value=$have->[$i];
      if(is_hashref($value)) {
        my $color=$value->{color};
        push @out,make_rule($def,$key,$value,$color);
        ++$i;
      } else {
        my $color=$have->[$i+1];
        push @out,make_rule($def,$key,$value,$color);
        $i+=2;
      };
    };
    return @out;
  };

  # ^nope, use inner table
  my ($value,$color)=(
    $def->fet($key),
    $PKG->KEYCOLOR_HASH->{$key},
  );
  return make_rule($def,$key,$value,$color);
};


# ---   *   ---   *   ---
# extract patterns from value

sub extract($def,$key,$value) {
  # scalar as-is
  return $value
  if ! length ref $value
  || is_qre $value;

  # ^arrayref as list
  return @$value
  if is_arrayref $value;

  # ^throw if not a hashref
  throw(
    "Invalid value type: "
  . sqwrap(ref $value)

  ) if ! is_hashref $value;

  # assume common delimiter sequence?
  return "start=\"$value->{beg}\" "
  .      "end=\"$value->{end}\""

  if is_cdelim($value);

  # ^plain hashref is... complicated ;>
  delete $value->{-re};

  my @keys = keys %$value;
  my @out  = ();


  # this abomination exists to accomodate sigils
  if(exists $def->{use_sigils}->{$key}) {
    my @exclude = ();
    my @noproc  = ();

    map {
      if(! ($ARG=~ m[ ^\(+ (\[\$ | \\\$) ]x)) {
        push @exclude,$ARG;

      } else {
        push @noproc,$ARG;

      };

    } @keys;

    @out  = @noproc;
    @keys = @exclude;
  };


  # output key lists in blocks
  # for some reason this is faster
  for(my $x=0;$x < @keys;$x+=32) {
    my $top=(@keys > $x+31)
      ? $x+31
      : $#keys
      ;

    my @slice=sort {
      (length $a) <= (length $b);

    } map {
      Arstd::Re::qre2re($ARG);
      $ARG;

    } (@keys[$x..$top]);

    # join them into a single expression
    push @out,($key eq 'num')
      ? '('   . (join '|',@slice) . ')'
      : '\b(' . (join '|',@slice) . ')\b'
      ;
  };

  return @out;
};


# ---   *   ---   *   ---
# output patterns for specific entry

sub make_rule($def,$key,$value,$color) {
  return () if ! defined $value;
  $color=get_color_name $color;

  return map {
    if(! is_cdelim($value)) {
      $ARG=~ s[\s+|\n][]sxmg;
      $ARG=  cat gstrip split "\n",$ARG;

      Arstd::Re::qre2re($ARG);
      $ARG=dqwrap $ARG;
    };

    "color $color $ARG";

  } extract($def,$key,$value);
};


# ---   *   ---   *   ---
# ^goes through all rules

sub get_file_syntax {
  return join "\n",map {
    prprops($_[0],$ARG);

  } ((Arstd::Array::nkeys $PKG->KEYCOLOR_LIST));
};


# ---   *   ---   *   ---
# iters through langdefs
# outs a nanorc file for each

sub make_syntax_files(%O) {
  # open dst file
  my ($def,$fpath)=($O{def},$O{fpath});
  open my $fh,'>',$fpath or throw $fpath;

  # nano syntax file boiler
  my $prop='syntax '.(
    $def->{name} .' "'.
    $def->{ext} . '"'

  )."\n";

  $prop .= 'header ' . dqwrap($def->{hed}) . "\n";
  $prop .= 'magic ' . dqwrap($def->{mag}) . "\n";


  # de-escape comments
  my $com=$def->{com};
  $com=~ s[\\][]sg;

  $prop .= 'comment ' . dqwrap($com) . "\n";


  # get base patterns list and
  # spit the whole thing out
  print {$fh} $prop . get_file_syntax $def;

  # cleanup and give
  close $fh or throw $fpath;
  return;
};


# ---   *   ---   *   ---
# entry point

sub generate {
  chdir $ENV{ARPATH}
  or throw "Error cd'ing into ARPATH";

  my ($config) = glob("~/.config");
  my $nanorc   = "$config/nano";

  reqdir($nanorc);


  # get whether any syntax files have changed
  my @file=map {
    my $src=$ARG;
    my $def=load_file $src;
    my $dst="$nanorc/$def->{name}.nanorc";

    (moo($dst,ftype_dir() . $src))
      ? [$dst,$def]
      : ()
      ;

  } get_files();

  # ^so as to only update when necessary
  return if ! @file;


  # run the generator
  use Log;
  Log->step('rebuilding syntax files');
  for(@file) {
    my ($dst,$def)=@$ARG;
    Log->substep($def->{name});
    make_syntax_files(
      def   => $def,
      fpath => $dst,
    );
  };

  return;
};

generate();


# ---   *   ---   *   ---
1; # ret
